;;;; graph.lisp ;graph network
;;graph-visualization.lisp (graphviz) in graph-utils

(in-package #:util)

(defun make-graph ()
  (>> 'nodes (>>) 'edges (>>) 'active-nodes '() 'path '() 'trace-start '() 'trace-end '())) ;trace short memory

(defun add-node (g &key (node nil) (props (>>)))
  (let ((nodes (>> g 'nodes)))
    (when (null node)
      (setf node (if (= 0 (hash-table-count nodes)) 0 (+ 1 (apply #'max (remove-if-not #'numberp (hash-keys nodes)))))))    
    (>> nodes node props)
    node))

(defun get-nodes (g &key (props (>>)))
  ;;when (props (>>)), return the nodes with empty properties rather than all nodes 
  (let ((nodes (>> g 'nodes)) (keys '()))
    (dolist (k (hash-keys nodes))
      (let ((switch 1))
	(if (equalp (>>) props)
	  (when (not (equalp props (>> nodes k)))
	    (setf switch 0))
	  (dolist (x (hash-keys props))
	    (when (not (equal (>> props x) (>> nodes `(,k ,x))))
	      (setf switch 0)
	      (return))))
	(when (= 1 switch)
	  (push k keys))))
    keys))

(defun add-edge (g &key (edge nil) (props (>>)) (weight 0.01))
  (let ((edges (>> g 'edges)))
    (when (null edge)
      (setf edge (if (= 0 (hash-table-count edges)) 0 (+ 1 (apply #'max (remove-if-not #'numberp (hash-keys edges)))))))
    (when weight (>> props 'weight weight))
    (>> edges edge props))
  edge)

(defun get-hrr-lst (&key (dic (>> 'a (>> 'hrr 1) 'b (>> 'hrr 2) 'c (>> 'hrr 5))) (lst '(a (b c))))
  (mapcar (lambda (x) (if (listp x) (get-hrr-lst :dic dic :lst x) (>> dic `(,x hrr)))) lst))
;;(get-hrr-lst :dic (>> 'a (>> 'hrr 1) 'b (>> 'hrr 2) 'c (>> 'hrr 5)) :lst '(a (b c)))

;; get some edges with same properties including nodes
(defun get-edges (g &key (nodes nil) (props (>>)) (type 'undirected)) ;;'undirected or 'directed 
  (when (not (null nodes))
    (>> props 'nodes nodes))
  (let ((edges (>> g 'edges)) (keys '()))
    (dolist (k (hash-keys edges))
      (let ((switch 1))
	(if (equalp (>>) props)
	  (when (not (equalp props (>> edges k)))
	    (setf switch 0))
	  (dolist (x (hash-keys props))
	    (let ((values0 (>> props x))
		   (values1 (>> edges `(,k ,x))))
	      (when (and (equal x 'nodes) (equal type 'undirected))
		;; now values0 is nodes items, values1 is edges(k)'s nodes items 
		(setf values0 (mapcar (lambda (e) (if (listp e) e (list e))) values0)) ;; for next step sorting sub-lists
		(setf values1 (mapcar (lambda (e) (if (listp e) e (list e))) values1)) ;; for next step sorting sub-lists
		(setf values0 (sort (copy-seq values0) #'list<))
		(setf values1 (sort (copy-seq values1) #'list<)))
	      (when (not (equal values0 values1))
		(setf switch 0)
		(return)))))
	(when (= 1 switch)
	  (push k keys))))
    keys))

(defun get-emanating-edges (g &key (node 0))  
  (let ((emanating-edges '()) (edges (>> g 'edges)))
    (loop for k in (hash-keys edges) do
      (let ((nodes (>> edges `(,k nodes))))
	(when (member node (flatten nodes) :test 'equal)
	  (push k emanating-edges))))
    emanating-edges))

(defun node-degree (g &key (node 0)) ;;edges may be (group2-edges g) 
  (let ((count 0) (edges (>> g 'edges)))
    (loop for k in (hash-keys edges) do
      (when (member node (flatten (>> edges `(,k nodes))) :test 'equal)
	(incf count)))
    count))

(defun neighbors (g &key (node 0))
  (let ((neighbors '()) (edges (>> g 'edges)))
    (loop for k in (hash-keys edges) do
      (let ((nodes (>> edges `(,k nodes))))
	(dotimes (i (length nodes))
	  (when (member node (flatten (list (nth i nodes))) :test 'equal)
	    (cond
	      ;; if node is the first one, it only has right neighbor(s)
	      ((= 0 i) (setf neighbors (append neighbors (flatten (list (nth (+ i 1) nodes))))))
	      ;; if node is the last one, it only has left neighbor(s)
	      ((= (- (length nodes) 1) i) (setf neighbors (append neighbors (flatten (list (nth (- i 1) nodes))))))
	      ;; otherwise, the node has both left and right neighbor(s)
	      (t (setf neighbors (append neighbors (flatten (list (nth (- i 1) nodes))) (flatten (list (nth (+ i 1) nodes)))))))))))
    (setf neighbors (remove node (list2set neighbors)))));; remove the node itself from the no-redundant neighbors

(defun get-in-edges (g &key (node 0) (choice nil))  
  (let ((in-edges '()) (edges (>> g 'edges)))
    (loop for k in (hash-keys edges) do
      (let ((nodes (>> edges `(,k nodes))))
	(when (member node (flatten (cdr nodes)) :test 'equal)
	  (push k in-edges))))
    (when (and in-edges (equal choice 'weighted-random-choice))
      (let ((in-edge nil))
	(tagbody
	  point0
	  (setf in-edge (second (weighted-random-choice (mapcar (lambda (edge) (list (>> g `(edges ,edge weight)) edge)) in-edges))))
	  (when (and (member 'max-depth (hash-keys (>> g `(edges ,in-edge))) :test 'equalp)
		  (not (null (>> g `(edges ,in-edge max-depth)))))
	    (if (> (>> g `(edges ,in-edge max-depth)) (>> g `(edges ,in-edge depth)))
	      (>> g `(edges ,in-edge depth) (+ (>> g `(edges ,in-edge depth)) 1))
	      (go point0))))
	(setf in-edges (list in-edge))))
    (reverse in-edges)))

(defun get-out-edges (g &key (node 0) (choice nil)) ;'weighted-random-choice
  (let ((out-edges '()) (edges (>> g 'edges)))
    (loop for k in (hash-keys edges) do
      (let ((nodes (>> edges `(,k nodes))))
	(when (member node (flatten (butlast nodes)) :test 'equal)
	  (push k out-edges))))
    (when (and out-edges (equal choice 'weighted-random-choice))
      (let ((out-edge nil))
	(tagbody
	  point0
	  (setf out-edge (second (weighted-random-choice (mapcar (lambda (edge) (list (>> g `(edges ,edge weight)) edge)) out-edges))))
	  (when (and (member 'max-depth (hash-keys (>> g `(edges ,out-edge))) :test 'equalp)
		  (not (null (>> g `(edges ,out-edge max-depth)))))
	    (if (> (>> g `(edges ,out-edge max-depth)) (>> g `(edges ,out-edge depth)))
	      (>> g `(edges ,out-edge depth) (+ (>> g `(edges ,out-edge depth)) 1))
	      (go point0))))
	(setf out-edges (list out-edge))))
    (reverse out-edges)))

(defun get-in-nodes (g &key (node 0) (choice nil)) ;'weighted-random-choice   
  (let ((in-edges (get-in-edges g :node node :choice choice)))
    (when in-edges (flatten (mapcar (lambda (edge) (car (>> g `(edges ,edge nodes)))) in-edges)))))

(defun get-input (g &key (node 0))
  (mapcar (lambda (node) (if (member 'output (hash-keys (>> g `(nodes ,node))) :test 'equal)
			   (>> g `(nodes ,node output))
			   'no-data))
    (get-in-nodes g :node node)))

(defun get-out-nodes (g &key (node 0) (choice nil)) ;'weighted-random-choice  
  (let ((out-edges (get-out-edges g :node node :choice choice)))
    (when out-edges (flatten (mapcar (lambda (edge) (cdr (>> g `(edges ,edge nodes)))) out-edges)))))

(defun get-output (g &key (nodes '(0 1 2)))
  (mapcar (lambda (node) (>> g `(nodes ,node output))) nodes))

(defun run-node0 (g &key (node 0))
  (if (member 'fun (hash-keys (>> g `(nodes ,node))) :test 'equal)
    (progn
      (>> g `(nodes ,node output) (eval (>> g `(nodes ,node fun))))
      ;;(show "node {} value: {}" node (>> g `(nodes ,node output)))
      (>> g `(nodes ,node output)))
    node))

(defun run-node (g &key (node 0))
  (if (member 'fun (hash-keys (>> g `(nodes ,node))) :test 'equal)
    (progn
      (when (member 'input (hash-keys (>> g `(nodes ,node))) :test 'equal)
	(let ((new-input (get-input g :node node))) (when (and new-input (not (member 'no-data new-input :test 'equal))) (>> g `(nodes ,node input) new-input)))
	;;(show "node {} input: {}" node (>> g `(nodes ,node input)))
	)
      (>> g `(nodes ,node output) (eval (>> g `(nodes ,node fun))))
      ;;(show "node {} value: {}" node (>> g `(nodes ,node output)))
      (>> g `(nodes ,node output)))
    node))

(defun run-nodes (g &key (nodes '(0 1 2)))
  (dolist (node nodes)
    (run-node g :node node)))

(defun clean-depth (g)
  (dolist (edge (hash-keys (>> g 'edges)))
    (when (and (member 'depth (hash-keys (>> g `(edges ,edge))) :test 'equalp) (/= (>> g `(edges ,edge depth)) 0))
      (>> g `(edges ,edge depth) 0))))

(defun trace-forward-nodes0 (g &key (nodes '(0 1 2)) (choice 'weighted-random-choice) (start t) (nonterminal? nil) (level nil))
  (let ((start2 start))
    (when start (>> g 'trace-end '()) (clean-depth g) (setf start nil))
    (dolist (node nodes) (run-node g :node node))
    (let ((new-trace '()))
      (dolist (node nodes)
	  (let ((new-nodes (get-out-nodes g :node node :choice choice)))
	    ;;(show "trace-forward-nodes new-nodes: {}" new-nodes)
	    (if (and new-nodes (or (null level) (> level 0)))
	      (progn
		(when nonterminal?
		  (setf new-trace (append new-trace (list (run-node g :node node)))))
		;;(when (not (null level)) (setf level (- level 1)))
		(let ((new-trace2 (trace-forward-nodes g :nodes new-nodes :choice choice :start start :nonterminal? nonterminal? :level (if (null level) nil (- level 1)))))
		  (when (not (null new-trace2))
		    (setf new-trace (append new-trace (list new-trace2))))))
	      (progn	  
		(setf new-trace (append new-trace (list (run-node g :node node))))
		node))))
      (setf new-trace (simplify-list new-trace))
      (when (and start2 (not (null new-trace)))
	(>> g 'trace-end new-trace))
      new-trace)))

(defun trace-edges0 (g &key (nodes '(tria up medium)) (path '(-35 -115 119 39)) (choice 'weighted-random-choice) (start t) (nonterminal? nil) (level nil) (clean-trace-end? t) (clean-path? t) (clean-trace-start? t) (mutate nil))
  (when start (clean-depth g) (setf start nil)
    (when clean-trace-end? (>> g 'trace-end '()))
    (when clean-trace-start? (>> g 'trace-start nodes))
    (when clean-path? (>> g 'path '())))
  (dolist (k path)
    (let ((part nil) (new-part nil))
      (if (>= k 0)
	(progn ;;trace-forward
	  (setf part (car (>> g `(edges ,k nodes)))) 
	  (setf new-part (second (>> g `(edges ,k nodes)))))
	(progn ;;trace-backward
	  (setf k (abs k))
	  (setf part (second (>> g `(edges ,k nodes)))) 
	  (setf new-part (car (>> g `(edges ,k nodes))))))
      (when (not (listp nodes)) (setf nodes (list nodes)))
      (setf nodes (replace* :item part :of nodes :with new-part)))) 
  (>> g 'trace-end nodes)
  (>> g 'path path)
  nodes)

(defun trace-edges (g &key (nodes '(tria up medium)) (path '(-35 -115 119 39)) (choice 'weighted-random-choice) (start t) (nonterminal? nil) (level nil) (clean-trace-end? t) (clean-path? t) (clean-trace-start? t) (gradient-mutate nil))
  (when start (clean-depth g) (setf start nil)
    (when clean-trace-end? (>> g 'trace-end '()))
    (when clean-trace-start? (>> g 'trace-start nodes))
    (when clean-path? (>> g 'path '())))
  (show "path before mutation: {}" path)
  (when gradient-mutate ;;the next one has more chance to mutate 
    (dotimes (i (length path))
      (let ((k (nth i path)))
	(when (< (random 1.0) (* gradient-mutate (/ (+ i 1) (length path))))
	  (if (>= k 0)
	    (let ((nodes (car (>> g `(edges ,k nodes)))))
	      (when (not (listp nodes)) (setf nodes (list nodes)))
	      (trace-forward-nodes g :nodes nodes :level 0)
	      (setf (nth i path) (car (>> g 'path))))
	    (let* ((k_ (- k)) (nodes (second (>> g `(edges ,k_ nodes)))))
	      (when (not (listp nodes)) (setf nodes (list nodes)))
	      (trace-backward-nodes g :nodes nodes :level 0)
	      (setf (nth i path) (- (car (>> g 'path)))))
	    )))))
  (show "path after mutation: {}" path)
  (dotimes (i (length path))
    (let ((k (nth i path)) (part nil) (new-part nil))
      (if (>= k 0)
	(progn ;;trace-forward
	  (setf part (car (>> g `(edges ,k nodes)))) 
	  (setf new-part (second (>> g `(edges ,k nodes)))))
	(progn ;;trace-backward
	  (setf k (abs k))
	  (setf part (second (>> g `(edges ,k nodes)))) 
	  (setf new-part (car (>> g `(edges ,k nodes))))))
      (when (not (listp nodes)) (setf nodes (list nodes)))
      (setf nodes (replace* :item part :of nodes :with new-part)))) 
  (>> g 'trace-end nodes)
  (>> g 'path path)
  nodes)

(defun trace-forward-nodes (g &key (nodes '(0 1 2)) (choice 'weighted-random-choice) (gate-edges '()) (start t) (nonterminal? nil) (level nil) (clean-trace-end? t) (clean-path? t) (clean-trace-start? t))
  (when start (clean-depth g) (setf start nil)
    (when clean-trace-end? (>> g 'trace-end '()))
    (when clean-trace-start? (>> g 'trace-start nodes))
    (when clean-path? (>> g 'path '())))
  (let ((rule-nodes '()))
    (dolist (k (hash-keys (>> g 'edges)))
      (let ((e (car (>> g `(edges ,k nodes))))
	     (weight (>> g `(edges ,k weight)))
	     (exist? nil))
	(when (listp e) (setf e (c2l e)))
	(if (null rule-nodes)
	  (push (list (list (list weight k)) e) rule-nodes)
	  (progn
	    (dotimes (i (length rule-nodes))
	      (when (equalp e (second (nth i rule-nodes))) ;;eg.(var x) (var y) the same car
		(push (list weight k) (car (nth i rule-nodes)))
		(setf exist? t)
		(return)))
	    (when (not exist?)
	      (push (list (list (list weight k)) e) rule-nodes))))))
    (setf rule-nodes (sort (copy-seq rule-nodes) #'cdr-list-len>)) ;;(show "rule-nodes {}" rule-nodes)
    (tagbody
      point0
      (setf nodes_ (copy-seq nodes)) ;;(show "nodes_ {}" nodes_)
      (dolist (rule rule-nodes) 
	(when (is-sub-list (flatten (cdr rule)) nodes)
	  (tagbody
	    point1
	    (let ((k (second (weighted-random-choice (car rule))))
		   (k0 (car (intersection gate-edges (mapcar (lambda (x) (second x)) (car rule))))))
	      ;;(show "(car rule): {} gate-edges: {} k0: {}" (mapcar (lambda (x) (second x)) (car rule)) gate-edges k0)
	      (when k0
		(if (and (member 'max-depth (hash-keys (>> g `(edges ,k0))) :test 'equalp)
			(not (null (>> g `(edges ,k0 max-depth)))))
		  (when (> (>> g `(edges ,k0 max-depth)) (>> g `(edges ,k0 depth)))
		    (setf k k0))
		  (setf k k0)))
	      (when (and (member 'max-depth (hash-keys (>> g `(edges ,k))) :test 'equalp)
		      (not (null (>> g `(edges ,k max-depth)))))
		(if (> (>> g `(edges ,k max-depth)) (>> g `(edges ,k depth)))
		  (>> g `(edges ,k depth) (+ (>> g `(edges ,k depth)) 1))
		  (go point1)))
	      (setf nodes (simplify-list (l2c (replace-lst0 :part (flatten (cdr rule)) :of nodes :with (list (second (>> g `(edges ,k nodes))))))))
	      (let ((path (>> g 'path)))
		(setf path (append path (list k)))
		(>> g 'path path))
	      (if (listp nodes)
		(setf nodes (c2l nodes))
		(setf nodes (list nodes)))))
	  (return)))
      (when (not (listp nodes)) (setf nodes (list nodes)))
      (when (and (not (equalp nodes nodes_)) (or (null level) (> level 0)))
	(when level (decf level))
	(go point0))))
  (setf nodes (simplify-list nodes))
  (>> g 'trace-end nodes)
  nodes)

(defun trace-backward-nodes (g &key (nodes '(0 1 2)) (choice 'weighted-random-choice) (gate-edges '()) (start t) (nonterminal? nil) (level nil) (clean-trace-end? t) (clean-path? t) (clean-trace-start? t))
  (when start (clean-depth g) (setf start nil)
    (when clean-trace-end? (>> g 'trace-end '()))
    (when clean-trace-start? (>> g 'trace-start nodes))
    (when clean-path? (>> g 'path '())))
  (let ((expan-nodes '()))
    (dolist (k (hash-keys (>> g 'edges)))
      (let ((e (second (>> g `(edges ,k nodes))))
	     (weight (>> g `(edges ,k weight)))
	     (exist? nil))
	(when (listp e) (setf e (c2l e)))
	(if (null expan-nodes)
	  (push (list (list (list weight k)) e) expan-nodes)
	  (progn
	    (dotimes (i (length expan-nodes))
	      (when (equalp e (second (nth i expan-nodes))) ;;eg.(sky (rect right ll)) (sce (rect right ll)) the same cdr
		(push (list weight k) (car (nth i expan-nodes)))
		(setf exist? t)
		(return)))
	    (when (not exist?)
	      (push (list (list (list weight k)) e) expan-nodes))))))
    (setf expan-nodes (sort (copy-seq expan-nodes) #'cdr-list-len>))
    (tagbody
      point0
      (setf nodes_ (copy-seq nodes)) ;;(show "nodes_ {}" nodes_)
      (dolist (expan expan-nodes) 
	(when (is-sub-list (flatten (cdr expan)) nodes)
	  (tagbody
	    point1
	    (let ((k (second (weighted-random-choice (car expan))))
		   (k0 (car (intersection gate-edges (mapcar (lambda (x) (second x)) (car expan))))))
	      ;;(show "(car expan): {} gate-edges: {} k0: {}" (mapcar (lambda (x) (second x)) (car expan)) gate-edges k0)
	      (when k0
		(if (and (member 'max-depth (hash-keys (>> g `(edges ,k0))) :test 'equalp)
		      (not (null (>> g `(edges ,k0 max-depth)))))
		  (when (> (>> g `(edges ,k0 max-depth)) (>> g `(edges ,k0 depth)))
		    (setf k k0))
		  (setf k k0)))
	      (when (and (member 'max-depth (hash-keys (>> g `(edges ,k))) :test 'equalp)
		      (not (null (>> g `(edges ,k max-depth)))))
		(if (> (>> g `(edges ,k max-depth)) (>> g `(edges ,k depth)))
		  (>> g `(edges ,k depth) (+ (>> g `(edges ,k depth)) 1))
		  (go point1)))
	      (setf nodes (simplify-list (l2c (replace-lst0 :part (flatten (cdr expan)) :of nodes :with (list (car (>> g `(edges ,k nodes))))))))
	      (let ((path (>> g 'path)))
		(setf path (append path (list (- k))))
		(>> g 'path path))
	      (if (listp nodes)
		(setf nodes (c2l nodes))
		(setf nodes (list nodes)))))
	  (return)))
      (when (not (listp nodes)) (setf nodes (list nodes)))
      (when (and (not (equalp nodes nodes_)) (or (null level) (> level 0)))
	(when level (decf level))
	(go point0))))
  (setf nodes (simplify-list nodes))
  (>> g 'trace-end nodes)
  nodes)

(defun trace-forward-nodes2 (g &key (nodes '(0 1 2)) (choice nil) (start t) (nonterminal? nil))
  (when start (>> g 'trace-end '()) (clean-depth g) (setf start nil))
  (let ((nodes-copy (copy-seq nodes)))
    (dolist (node nodes)
      (when (equal #\! (char (string node) 0))
	(let ((edge (str2num (string (second (split node :gap '!))))))
	  (setf new-nodes (flatten (list '[ (>> g `(edges ,edge name)) (>> g `(edges ,edge nodes)) '])))
	  (setf nodes-copy (replace-lst :part (list node) :of nodes-copy :with new-nodes)))))
    (setf nodes (copy-seq nodes-copy)))
  (dolist (node nodes) (run-node g :node node))
  (dolist (node nodes)
    (let ((new-nodes (get-out-nodes g :node node :choice choice)))
      (if new-nodes
	(progn
	  (when nonterminal?
	    (let ((trace0 (>> g 'trace-end)))
	      (setf trace0 (append trace0 (list (run-node g :node node))))
	      (>> g 'trace-end trace0)))
	  (trace-forward-nodes2 g :nodes new-nodes :choice choice :start start :nonterminal? nonterminal?))
	(progn
	  ;;(show "{}" node)
	  (let ((trace0 (>> g 'trace-end)))
	    (setf trace0 (append trace0 (list (run-node g :node node))))
	    (>> g 'trace-end trace0))
	  node)))))

(defun test-trace-forward-nodes2 (&key (g (make-graph)))
  (add-node g :node '[ :props (>> 'utter? t))
  (add-node g :node '] :props (>> 'utter? t))
  (add-node g :node 'touch :props (>> 'utter? t))
  (add-node g :node 'in :props (>> 'utter? t))
  (add-edge g :edge 20 :props (>> 'name 'touch 'nodes '(wal rof)))  
  (add-edge g :edge 0 :props (>> 'name 'expan 'nodes '(bt !20)))
  (add-edge g :edge 21 :props (>> 'name 'in 'nodes '(win wal)))
  (add-edge g :edge 1 :props (>> 'name 'expan 'nodes '(bt !21)))
  ;;(trace-forward-nodes2 g :nodes '(bt) :choice 'weighted-random-choice)
  (show "{}" g)
  )
;;(test-trace-forward-nodes2)

(defun trace-fb-nodes (g &key (nodes '(0 1 2)) (choice nil) (start t) (nonterminal? t));both forward and backward
  ;;find component of graph
  (when start (>> g 'trace-end '()) (clean-depth g) (setf start nil))
  (dolist (node nodes) (run-node g :node node))
  (dolist (node nodes)
    (let ((new-nodes (remove-if (lambda (n) (member n (list2set (append nodes (flatten (>> g 'trace-end)))) :test 'equalp)) (neighbors g :node node))))
      (if new-nodes
	(progn
	  (when nonterminal?
	    (let ((trace0 (>> g 'trace-end)))
	      (setf trace0 (list2set (append trace0 (list (run-node g :node node)))))
	      (>> g 'trace-end trace0)))
	  (trace-fb-nodes g :nodes new-nodes :choice choice :start start :nonterminal? nonterminal?))
	(progn
	  ;;(show "{}" node)
	  (let ((trace0 (>> g 'trace-end)))
	    (setf trace0 (list2set (append trace0 (list (run-node g :node node)))))
	    (>> g 'trace-end trace0))
	  node)))))

(defun run-edges (g &key (edges '(0 1 2)))
  (dolist (edge edges)
    (run-nodes g :nodes (flatten (>> g `(edges ,edge nodes))))))

;;(defun very (&optional (size '(* size0 2))) (list (car size) size (car (last size))))
;;(eval (replace* :item 'size0 :of (very (very '(/ size0 2))) :with 1))

(defun init-relations (&key (r (make-graph)) (scene (get-scene3)))
  (add-edge r :nodes '(oper and))
  ;;(add-edge r :nodes '(oper /))
  ;;(add-edge r :nodes '(oper *))

  ;;(add-edge r :nodes '(medium (* size0 1)))
  ;;(add-edge r :nodes '(small (/ size0 2)))
  ;;(add-edge r :nodes '(large (* size0 2)))
  (add-edge r :nodes '(size medium))
  (add-edge r :nodes '(size small))
  (add-edge r :nodes '(size large))
  (add-edge r :nodes '(size (very size)) :props (>> 'max-depth 2 'depth 0))
  (let ((size-now (trace-forward-nodes r :nodes '(size)))
	 (base-size 100))
    (show "trace-forward-nodes (size) {}" size-now)
    (show "calculate size-now {}" (get-size size-now base-size))
    )
  (show "trace medium -> <- {}" (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(medium)))))
  ;; add utterance for size such as small.
  (dolist (size '(medium small large)) (>> r `(nodes ,size utter) (list (list 0.01 (random-word)))))
  
  ;;(add-edge r :nodes '(scale very))
  ;;(add-edge r :nodes '(zero (plus minus)) :order? nil)
  ;;(add-edge r :nodes '(mm (size zero)) :order? t)
  ;;(add-edge r :nodes '(ms (mm minus)) :order? t)
  ;;(add-edge r :nodes '(ml (mm plus)) :order? t)
  ;;(add-edge r :nodes '(sm (size minus)) :order? t)
  ;;(add-edge r :nodes '(ss (sm minus)) :order? t)
  ;;(add-edge r :nodes '(sl (sm plus)) :order? t)
  ;;(add-edge r :nodes '(lm (size plus)) :order? t)
  ;;(add-edge r :nodes '(ls (lm minus)) :order? t)
  ;;(add-edge r :nodes '(ll (lm plus)) :order? t)
  
  ;; add utterance for sizes such as ss.
  ;;(dolist (size '(mm ms ml sm ss sl lm ls ll)) (>> r `(nodes ,size utter) (list (list 0.01 (random-word)))))
  ;;(show "(cosine-distan ss sm) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes sm hrr))))
  ;;(show "(cosine-distan ss sl) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes sl hrr))))
  ;;(show "(cosine-distan ss ms) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes ms hrr))))
  ;;(show "(cosine-distan ss mm) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes mm hrr))))
  ;;(show "(cosine-distan ss ml) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes ml hrr))))
  ;;(show "(cosine-distan ss ls) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes ls hrr))))
  ;;(show "(cosine-distan ss lm) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes lm hrr))))
  ;;(show "(cosine-distan ss ll) {}" (cosine-distan (>> r `(nodes ss hrr)) (>> r `(nodes ll hrr))))
  
  (add-edge r :nodes '(shape tria))
  (add-edge r :nodes '(shape rect))
  (add-edge r :nodes '(shape elli))
  ;;(add-edge r :nodes '(shape (shape shape)) :props (>> 'max-depth 1 'depth 0)) ;eg. (tria rect)
  
  (add-edge r :nodes '(direct hori))
  (add-edge r :nodes '(direct verti))
  (add-edge r :nodes '(hori left))
  (add-edge r :nodes '(hori right))
  (add-edge r :nodes '(verti up))
  (add-edge r :nodes '(verti down))
  (add-edge r :nodes '(direct (direct direct)) :props (>> 'max-depth 1 'depth 0));;eg. (up right)
  (trace-forward-nodes r :nodes '(direct)) (show "trace-end {}" (>> r 'trace-end))
  (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(down)))) (show "trace-end down-> <- {}" (>> r 'trace-end))
  (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(down right)))) (show "trace-end (down right) -> <- {}" (>> r 'trace-end))
  
  (add-edge r :nodes '(relate int))
  ;;(add-edge r :nodes '(tin (int minus)) :order? nil)
  ;;(add-edge r :nodes '(in (tin minus)) :order? nil)
  ;;(add-edge r :nodes '(on (int plus)) :order? nil)
  ;;(add-edge r :nodes '(to (on plus)) :order? nil)
  (add-edge r :nodes '(relate tin))
  (add-edge r :nodes '(relate in))
  (add-edge r :nodes '(relate on))
  (add-edge r :nodes '(relate to))
  ;; add utterance for relations such as in.
  (dolist (re '(tin in on to)) (>> r `(nodes ,re utter) (list (list 0.01 (random-word)))))
  (trace-forward-nodes r :nodes '(relate) :level 1) (show "trace-end {}" (>> r 'trace-end))

  (add-edge r :nodes '(relation (relate direct)))
  (add-edge r :nodes '(pair-obj (relation obj obj)))
  (add-edge r :nodes '(obj (shape direct size)))
  (add-edge r :nodes '(obj (relation obj obj)) :props (>> 'max-depth 1 'depth 0) :weight 1)
  ;;(show "(cosine-distan in tin) {}" (cosine-distan (>> r `(nodes in hrr)) (>> r `(nodes tin hrr))))
  ;;(show "(cosine-distan in int) {}" (cosine-distan (>> r `(nodes in hrr)) (>> r `(nodes int hrr))))
  ;;(show "(cosine-distan in on) {}" (cosine-distan (>> r `(nodes in hrr)) (>> r `(nodes on hrr))))
  ;;(show "(cosine-distan in to) {}" (cosine-distan (>> r `(nodes in hrr)) (>> r `(nodes to hrr))))
  #| 
  (add-edge r :nodes '(lan (rect large)) :order? nil)
  (add-edge r :nodes '(sky (rect large)) :order? nil)
  (add-edge r :nodes '(sun (elli small)) :order? nil)
  (add-edge r :nodes '(sun-sky (in sun sky)) :order? t)
  (add-edge r :nodes '(roof (tria medium)) :order? nil)
  (add-edge r :nodes '(wall (rect medium)) :order? nil)
  (add-edge r :nodes '(house (on roof wall)) :order? t)
  (add-edge r :nodes '(house-lan (on house lan)) :order? t)
  (add-edge r :nodes '(crown (tria small)) :order? nil)
  (add-edge r :nodes '(trunk (rect medium)) :order? nil)
  (add-edge r :nodes '(tree (on crown trunk)) :order? t)
  (add-edge r :nodes '(tree-lan (on tree lan)) :order? t) (trace-forward-nodes r :nodes '(tree-lan))
  (add-edge r :nodes '(tree-lan2 (in tree lan)) :order? t)
  
  (show "(cosine-distan house tree) {}" (cosine-distan (>> r `(nodes house hrr)) (>> r `(nodes tree hrr))))
  (show "(cosine-distan house sun) {}" (cosine-distan (>> r `(nodes house hrr)) (>> r `(nodes sun hrr))))
  (show "(cosine-distan lan sky) {}" (cosine-distan (>> r `(nodes lan hrr)) (>> r `(nodes sky hrr))))
  (show "(cosine-distan house-lan tree-lan) {}" (cosine-distan (>> r `(nodes house-lan hrr)) (>> r `(nodes tree-lan hrr))))
  (show "(cosine-distan tree-lan tree-lan2) {}" (cosine-distan (>> r `(nodes tree-lan hrr)) (>> r `(nodes tree-lan2 hrr))))
  (show "(cosine-distan house-lan sun-sky) {}" (cosine-distan (>> r `(nodes house-lan hrr)) (>> r `(nodes sun-sky hrr))))
  |#
  r)
;;(init-relations)
  
;; each node is made with a list of two sub-lists of nodes, the first sub-list is "rule" while the second sub-list is "expansion"
(defun get-relations (&key (r (make-graph)) (scene (get-scene3)))
  (dolist (name0 (hash-keys scene))
    (dolist (name1 (hash-keys scene))
      (when (and (not (equal name0 name1))
	      (not (member name0 '(sce sky sun sea lan)))
	      (not (member name1 '(sce sky sun sea lan))))
	(let* ((obj0 (>> scene name0))
		(obj1 (>> scene name1))
		(poly0 (obj2polygon obj0))
		(poly1 (obj2polygon obj1))
		(in-out? (in-out poly0 poly1))
		(touch? (polygon0-touch-polygon1 poly0 poly1))
		(direction? (name-direction :terminal (centroid-of-polygon poly0) :origin (centroid-of-polygon poly1))))
	  (when (not (and (null touch?) (or (equal in-out? 'out) (equal in-out? 'to))))
	    (if (equal in-out? 'contain)
	      (add-edge r :edge (l2s (list name1 name0)) :props (>> 'feature (list (list 1 (if touch? 'tin 'in) (name-direction :terminal (centroid-of-polygon poly1) :origin (centroid-of-polygon poly0))))))
	      (let ((switch t))
		(dolist (e (hash-values (>> r 'edges)))
		  (when (and (listp (cadr (>> e 'nodes))) (> (length (cadr (>> e 'nodes))) 2))
		    (when (or (equalp (cdadr (>> e 'nodes)) (list name0 name1)) (equalp (cdadr (>> e 'nodes)) (list name1 name0)))
		      (setf switch nil))))
		(when (member direction? '(down right) :test 'equal) (setf switch nil));avoid (down wal rof) but keep (up rof wal)
		(when switch
		  (add-edge r :edge (l2s (list name0 name1)) :props (>> 'feature (list (list 1 in-out? direction?))))
		  ;;(add-edge r :edge (l2s (list 'pair-obj (list name0 name1))) :props (>> 'expan t))
		  ))))))))
  r)
;;(show "get-relations {}" (get-relations))
;;(show "{}" (let* ((relations (get-relations)) (edges (>> relations 'edges))) (get-components :edges edges)))

(defun get-relations-compo (&optional (r (make-graph)) (s (get-scene3)))
  (dolist (name0 '(fish boat tree house))
    (dolist (name1 '(lan sea))
      (let* ((obj0 (>> r `(nodes ,name0)))
	      (obj1 (>> s name1))
	      (poly0 (>> obj0 'outline))
	      (poly1 (obj2polygon obj1))
	      (in-out? (in-out poly0 poly1))
	      (touch? (polygon0-touch-polygon1 poly0 poly1))
	      (direction? (name-direction :terminal (list (>> obj0 'x) (>> obj0 'y)) :origin (centroid-of-polygon poly1))))
	(when (not (and (null touch?) (or (equal in-out? 'out) (equal in-out? 'to))))
	  (if (equal in-out? 'contain)
	    (add-edge r :edge (l2s (list name1 name0)) :props (>> 'feature (list (list 1 (if touch? 'tin 'in) (name-direction :terminal (centroid-of-polygon poly1) :origin (centroid-of-polygon poly0))))))
	    (let ((switch t))
	      (dolist (e (hash-values (>> r 'edges)))
		(when (and (listp (cadr (>> e 'nodes))) (> (length (cadr (>> e 'nodes))) 2))
		  (when (or (equalp (cdadr (>> e 'nodes)) (list name0 name1)) (equalp (cdadr (>> e 'nodes)) (list name1 name0)))
		    (setf switch nil))))
	      (when (member direction? '(down right) :test 'equal) (setf switch nil));avoid (down wal rof) but keep (up rof wal)
	      (when switch
		(add-edge r :edge (l2s (list name0 name1)) :props (>> 'feature (list (list 1 in-out? direction?))))
		;;(add-edge r :edge (l2s (list 'pair-obj (list name0 name1))) :props (>> 'expan t))
		)))))))
  ;;sun and sky
  (let* ((obj0 (>> s 'sun))
	 (obj1 (>> s 'sky))
	 (poly0 (obj2polygon obj0))
	 (poly1 (obj2polygon obj1))
	 (in-out? (in-out poly0 poly1))
	 (direction? (name-direction :terminal (centroid-of-polygon poly0) :origin (centroid-of-polygon poly1))))
    (add-edge r :edge (l2s '(sun sky)) :props (>> 'feature (list (list 1 in-out? direction?)))))
  r)

(defun get-components0 (g)
  (let* ((components '())
	  (nodes (list2set (flatten (mapcar (lambda (v) (>> v 'nodes)) (hash-values (>> g 'edges))))))
	  (node (random-choice nodes)))
    (when nodes
      (loop do
	(setf node (random-choice nodes))
	(trace-fb-nodes g :nodes (list node) :nonterminal? t)
	(push (>> g 'trace-end) components)
	(setf nodes (remove-if (lambda (n) (member n (flatten components))) nodes))
	while nodes))
    components))

;;(show "{}" (get-components0 (>> 'nodes (>> 'wal (>>) 'rof (>>) 'win (>>) 'dor (>>) 'trk (>>) 'cro (>>) 'crw (>>) 'hul (>>) 'bow (>>) 'pop (>>) 'sal (>>) 'fad (>>) 'fdy (>>) 'fye (>>) 'fil (>>)) 'edges (>> 0 (>> 'nodes '(wal rof)) 1 (>> 'nodes '(win wal)) 2 (>> 'nodes '(dor wal)) 3 (>> 'nodes '(trk cro)) 4 (>> 'nodes '(cro crw)) 5 (>> 'nodes '(hul bow)) 6 (>> 'nodes '(hul pop)) 7 (>> 'nodes '(hul sal)) 8 (>> 'nodes '(fad fdy)) 9 (>> 'nodes '(fye fad)) 10 (>> 'nodes '(fdy fil)))))) ;-->((CRO TRK CRW) (SAL HUL BOW POP) (WAL ROF WIN DOR) (FYE FAD FDY FIL))

(defun get-components (&key (edges (>> 0 (>> 'nodes '(bt (touch wal rof))) 1 (>> 'nodes '(bt (in win wal))) 2 (>> 'nodes '(bt (in dor wal))) 3 (>> 'nodes '(bt (touch trk cro))) 4 (>> 'nodes '(bt (touch cro crw))) 5 (>> 'nodes '(bt (touch hul bow))) 6 (>> 'nodes '(bt (touch hul pop))) 7 (>> 'nodes '(bt (touch hul sal))) 8 (>> 'nodes '(bt (touch fad fdy))) 9 (>> 'nodes '(bt (in fye fad))) 10 (>> 'nodes '(bt (touch fdy fil))))) (scene (get-scene3)))
  (let ((components (>>)))
    (dolist (k (hash-keys edges))
      ;;(dolist (obj (cdr (second (>> edges `(,k nodes)))))
      (let ((expan (cadr (>> edges `(,k nodes)))))
	(when (and (listp expan) (listp (car (l2c expan)))) 
	  (dolist (obj (reverse (subseq (reverse (second (>> edges `(,k nodes)))) 0 2)));'(bt (touch wal rof))->'(touch wal rof)->'(rof wal)->'(wal rof)
	    (if (and (not (equalp components (>>))) (member obj (hash-keys components) :test 'equal))
	      (let ((edges-now (>> components obj)))
		(push k edges-now)
		(setf edges-now (list2set edges-now))
		(>> components obj edges-now))
	      (>> components obj (list k)))))))
    (setf components (mapcar (lambda (k) (list (list k) (>> components k)))(hash-keys components)))
    (tagbody
      point0
      (dolist (k0 components)
	(dolist (k1 components)
	  (when (not (equal k0 k1))
	    (when (intersection (second k0) (second k1))
	      (push (list (append (car k0) (car k1)) (union (second k0) (second k1))) components)
	      (setf components (remove k0 components))
	      (setf components (remove k1 components))
	      (go point0))))))
    ;;remove edges with directions (on down) (on right) which are redundant with (on up) (on right) 
    (tagbody
      point1
      (dolist (co components)
	(dolist (k (second co))
	  (let ((direction (car (l2c (second (>> edges `(,k nodes)))))))
	    (when (member direction '((on down) (on right)) :test 'equalp)
	      (setf (second co) (remove k (second co)))
	      (go point1))))))
    ;;sort edges according to their combined area, greater area is more important
    (let ((components-new '()))
      (dolist (co components)
	(let ((co-new '())
	       (co-new-nodes (car co))
	       (co-new-edges '()))
	  (dolist (k (second co))
	    (let* ((nodes (l2c (second (>> edges `(,k nodes)))))
		    (objs (cdr nodes))
		    (relation (caar nodes))
		    (polygons (mapcar (lambda (k) (obj2polygon (>> scene k))) objs))
		    (area nil)
		    )
	      (if (or (equal relation 'in) (equal relation 'tin))
		(setf area (abs (area-polygon (second polygons))))
		(setf area (reduce #'+ (mapcar (lambda (poly) (abs (area-polygon poly))) polygons))))
	      (show "components objs: {} edge: {} area: {}" objs k area)
	      (setf co-new-edges (append co-new-edges (list (list area k))))))
	  (setf co-new-edges (sort co-new-edges #'list>))
	  (setf co-new-edges (mapcar (lambda (x) (second x)) co-new-edges))
	  (setf co-new (append (list co-new-nodes) (list co-new-edges)))
	  (setf components-new (append components-new (list co-new)))))
      (show "components-new: {}" components-new)
      (setf components (copy-seq components-new)))
    components))
;;(show "{}" (get-components))
;;(((fad fdy fye fil) (9 8 10)) ((hul bow pop sal) (6 5 7)) ((trk cro crw) (3 4)) ((wal rof win dor) (1 0 2)))

(defun test-graph ()
  (defparameter g (make-graph))
  (add-node g :props (>> 'name '!s 'weight 0.2))
  (add-node g :props (>> 'name '!s 'weight 0.2))
  (show "nodes: {}" (hash2lst (>> g 'nodes)))
  (show "(get-nodes g): {}"(get-nodes g)) ;;default: return nodes with empty hash, i.e. (>>) rather than all nodes
  (show "(get-nodes g :props (>> 'name '!s)): {}"(get-nodes g :props (>> 'name '!s)))  
  (>> g '(nodes 0 weight) 0.01)
  (show "(get-nodes g :props (>> 'name '!s 'weight 0.01)): {}"(get-nodes g :props (>> 'name '!s 'weight 0.01)))
  (show "nodes: {}" (hash2lst (>> g 'nodes)))  
  (add-node g :props (>> 'name '!np_!vp 'weight 0.34 'color 'red))
  (show "nodes: {}" (hash2lst (>> g 'nodes)))
  (show "(>> g '(nodes 2 weight)): {}" (>> g '(nodes 2 weight)))
  (add-edge g) ;;nothing. empty edge
  (add-edge g :props (>> 'weight 0.1)) ;;without nodes
  (add-edge g :props (>> 'nodes '(0 0) 'weight 0.9))
  ;;TODO: seperate nodes from props or not?
  (add-edge g :nodes '(0 0) :props (>> 'weight 0.9))
  (add-edge g :nodes '(0 1))
  (add-edge g :nodes '(1 0))
  (add-edge g :nodes '(1 (3 6 1)))
  (add-edge g :nodes '(2 3))
  (add-edge g :nodes '(2 3 9))
  (add-edge g :nodes '(3 (3 7 1)))
  (show "nodes: {}" (hash2lst (>> g 'nodes)))
  (show "edges: {}" (hash2lst (>> g 'edges)))
  (show "(node-degree g :node 3): {}"(node-degree g :node 3))
  (show "(neighbors g :node 3): {}"(neighbors g :node 3))
  (show "(get-nodes g): {}"(get-nodes g))
  (show "(get-edges g): {}"(get-edges g))
  (show "(get-edges g): {}"(get-edges g :nodes nil :props (>>) :type 'undirected))
  (show "(get-edges g :nodes '(0 1)): {}"(get-edges g :nodes '(0 1) :props (>>) :type 'undirected))
  (show "(get-edges g :nodes '(0 1) :type 'directed): {}"(get-edges g :nodes '(0 1) :props (>>) :type 'directed))
  (show "(get-edges g :props (>> 'weight 0.9)): {}"(get-edges g :nodes nil :props (>> 'weight 0.9) :type 'undirected))
  (show "(get-edges g :nodes '(0 1) :props (>> 'weight 0.9)): {}"(get-edges g :nodes '(0 1) :props (>> 'weight 0.9) :type 'undirected))
  (show "(get-emanating-edges g :node 0): {}" (get-emanating-edges g :node 0))
  (show "(get-in-edges g :node 0): {}" (get-in-edges g :node 0))
  (show "(get-out-edges g :node 0): {}" (get-out-edges g :node 0))
  (add-node g :props (>> 'nodes '(1 2 3)))
  ;;(add-node g :props (>> 'nodes (>> g 'edges)))
  (add-node g :node 100 :props (>> 'fun '(random 100) 'output 100))
  (add-node g :node 101 :props (>> 'output 101))
  (add-node g :node 102 :props (>> 'output 200))
  (add-node g :node 'add :props (>> 'fun '(apply #'+ (get-input g :node 'add)) 'output nil))
  ;;(add-node g :node 'add :props (>> 'fun '(get-input g :node 'add) 'output nil))
  (add-edge g :nodes '((100 101) add))
  (run-node g :node 'add)
  (add-edge g :nodes '(102 add))
  (run-node g :node 'add)

  (run-node g :node 100)
  (run-node g :node 'add)
  (show "(trace-forward-nodes g :nodes '(100))...")
  (dotimes (i 2) (trace-forward-nodes g :nodes '(100)))
  
  ;;(add-node g :node 'init-bottle :props (>> 'fun '(car (get-input g :node 'init-bottle)) 'output 20))
  (add-node g :node 'init-bottle :props (>> 'input 20 'fun '(car (>> g `(nodes init-bottle input))) 'output 20))
  (add-node g :node 'bottle :props (>> 'input 20 'fun '(let ((n (car (>> g `(nodes bottle input))))) (show "bottles: {}" n) (if (> n 10) (decf n) (progn (remhash 'bottle->init-bottle (>> g 'edges)) n))) 'output 20))
  (add-edge g :nodes '(init-bottle bottle))
  (add-edge g :edge 'bottle->init-bottle :nodes '(bottle init-bottle))
  (show "(trace-forward-nodes g :nodes '(init-bottle))...")
  (trace-forward-nodes g :nodes '(init-bottle))
  (show "the result of init-bottle and bottle: {}" (get-output g :nodes '(init-bottle bottle)))

  ;;(add-edge g :edge 's>np_vp :nodes '(s (np vp)) :props (>> 'weight 0.01))  
  (add-edge g :nodes '(s (np vp)) :props (>> 'weight 0.01))
  (add-edge g :nodes '(np (a n)) :props (>> 'weight 0.01))
  (add-edge g :nodes '(n cat) :props (>> 'weight 0.01))
  (add-edge g :nodes '(n dog) :props (>> 'weight 0.01))
  (add-edge g :nodes '(n weinermobile) :props (>> 'weight 0.01))
  (add-edge g :nodes '(n duchess) :props (>> 'weight 0.01))
  (add-edge g :nodes '(vp (v np)) :props (>> 'weight 0.01))
  (add-edge g :nodes '(vp (vp and vp)) :props (>> 'weight 0.01 'max-depth 2 'depth 0))
  (add-edge g :nodes '(v sees) :props (>> 'weight 0.01))
  (add-edge g :nodes '(v chases) :props (>> 'weight 0.01))
  (add-edge g :nodes '(v lusts-after) :props (>> 'weight 0.01))
  (add-edge g :nodes '(v blames) :props (>> 'weight 0.01))
  (add-edge g :nodes '(a the) :props (>> 'weight 0.01))
  
  (show "(trace-forward-nodes g :nodes '(s))...")
  (dotimes (i 2)
    (trace-forward-nodes g :nodes '(s) :choice 'weighted-random-choice)
    (show "{}" (>> g 'trace-end)))

  (add-node g :node 'x :props (>> 'fun '(random 10) 'output 1))
  (add-node g :node 'y :props (>> 'fun '(random 10) 'output 2))
  (add-node g :node 'r :props (>> 'fun '(random 10) 'output 3))
  (add-node g :node 'h :props (>> 'fun '(random 10) 'output 4))
  ;;(add-edge g :nodes '(vars (x y r h)) :props (>> 'weight 0.01))
  (add-edge g :nodes '(a x) :props (>> 'weight 0.1))

  (defparameter bt (make-graph))
  (add-edge bt :nodes '(bt ([ oper var var ])) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(var bt) :props (>> 'weight 0.01 'max-depth 2 'depth 0));if max-depth=0, this edge will not be used.
  (add-edge bt :nodes '(var x) :props (>> 'weight 0.01));;(car (split 'x_)) -> 'x  'x_: terminal, 'x: real var connecting functions
  (add-edge bt :nodes '(var y) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(var r) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(var h) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(oper <) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(oper and) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(oper -) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(oper +) :props (>> 'weight 0.01))
  (show "(trace-forward-nodes bt :nodes '(bt))...")
  
  (dotimes (i 10)
    (show "times: {}" i)
    (trace-forward-nodes bt :nodes '(bt) :choice 'weighted-random-choice)
    (show "{}" (l2c (>> bt 'trace-end)))    
    (let* ((var-lst (get-out-nodes bt :node 'var))
	    (var-names (list2set (remove-if-not (lambda (node) (member node var-lst :test 'equalp)) (copy-seq (>> bt 'trace-end)))))
	    (fun-node (+ 1 (reduce #'max (remove-if-not #'numberp (hash-keys (>> g 'nodes))))))
	    (fun (car (l2c (mapcar (lambda (n) (if (member n var-lst :test 'equal) `(>> g '(nodes ,n output)) n)) (>> bt 'trace-end))))))
      (ignore-errors ;;error (eval '(< (> 0.52 0.79) 0.52)) --> '(< nil 0.52) <-- ignore-errors
	(when (eval fun) (add-node g :props (>> 'fun fun 'output 0))
	  (show "add-edge {}" (list var-names fun-node))
	  (add-edge g :nodes (list var-names fun-node) :props (>> 'weight 0.01))
	  (run-edges g :edges (list (reduce #'max (remove-if-not #'numberp (hash-keys (>> g 'edges))))))))))
  (trace-forward-nodes g :nodes '(s and s) :choice 'weighted-random-choice)
  (show "{}" (>> g 'trace-end))
  (show "g: {}" g)
  (show "bt: {}" bt)
  (show "(get-input g :node 'add): {}" (get-input g :node 'add))
  (add-node g :node 'add2 :props (>> 'input '(1 2) 'fun '(apply #'+ (>> g `(nodes add2 input))) 'output nil))
  (add-edge g :nodes '(s add2))
  (show "(run-node g :node 'add2) {}" (run-node g :node 'add2))
  )
;;(test-graph)

(defun test-house-graph ()
  (defparameter scene (get-scene3)) (show "scene3 {}" scene)
  (defparameter g (make-graph)) (show "graph {}" g)
  (defparameter r (make-graph)) ;relations
  (defparameter size-gng (make-gng)) ;including compo-objects like house
  (>> size-gng 'max-nodes 3)
  #|
  (add-node g :node 'pair-names :props (>> 'fun '(random-sample (hash-keys scene) 2) 'output '(sun sky)))
  (add-node g :node 'pair-names2 :props (>> 'fun (list 'fad 'fdy) 'output '(sun sky)))
  (add-node g :node 'pair-objects :props (>> 'fun '(mapcar (lambda (k) (>> scene k)) (car (get-input g :node 'pair-objects))) 'output (list (>>) (>>))))
  (add-edge g :nodes '(pair-names pair-objects) :props (>> 'weight 0.01))
  (add-edge g :nodes '(pair-names2 pair-objects) :props (>> 'weight 0.01))
  (add-node g :node 'pair-polygons :props (>> 'fun '(mapcar (lambda (obj) (obj2polygon obj)) (car (get-input g :node 'pair-polygons))) 'output '()))
  (add-edge g :nodes '(pair-objects pair-polygons) :props (>> 'weight 0.01))
  (add-node g :node 'in-out? :props (>> 'fun '(apply #'in-out (car (get-input g :node 'in-out?))) 'output 'nil))
  (add-edge g :nodes '(pair-polygons in-out?) :props (>> 'weight 0.01))
  (add-node g :node 'touch? :props (>> 'fun '(apply #'polygon0-touch-polygon1 (car (get-input g :node 'touch?))) 'output 'nil))
  (add-edge g :nodes '(pair-polygons touch?) :props (>> 'weight 0.01))
  (add-node g :node 'pair-centers :props (>> 'fun '(mapcar (lambda (polygon) (centroid-of-polygon polygon)) (car (get-input g :node 'pair-centers))) 'output '()))
  (add-edge g :nodes '(pair-polygons pair-centers) :props (>> 'weight 0.01))
  (add-node g :node 'direction? :props (>> 'fun '(apply #'name-direction (car (get-input g :node 'direction?))) 'output 'nil))
  (add-edge g :nodes '(pair-centers direction?) :props (>> 'weight 0.01))
  |#
  (get-relations :r r :scene scene)
  (let* ((components (get-components :edges (>> r 'edges)))
	  (component-names (mapcar (lambda (item) (car item)) components))
	  (component-edges (mapcar (lambda (item) (second item)) components))
	  (compo-objs '(fish boat tree house))
	  (degrees (mapcar (lambda (component) (mapcar (lambda (obj) (node-degree r :node obj)) component)) component-names))
	  (areas (mapcar (lambda (component) (mapcar (lambda (obj) (abs (area-polygon (obj2polygon (>> scene obj))))) component)) component-names)))
    (show "component-names {}" component-names)
    (show "degrees {}" degrees)
    (show "areas {}" areas)
    (mapcar (lambda (co-obj compo-names edges) (add-edge r :nodes (list co-obj (list (join (list co-obj 'o)) (mapcar (lambda (x) (join (list x 'o))) compo-names) (mapcar (lambda (edge) (second (>> r `(edges ,edge nodes)))) edges))) :props (>> 'weight 0.01))) '(fish boat tree house) component-names component-edges)
    (dolist (k (hash-keys (>> r 'edges))) (>> r `(edges ,k weight) 0.01))
    ;;(add-edge r :nodes '(sal ([ sail tria right medium ])) :props (>> 'weight 0.01))
    ;;(add-edge r :nodes '(boat ([ hul sal bow pop ])) :props (>> 'weight 0.01))
    ;;(add-edge r :nodes '(bt ([ [ intersect 0 [ up left ] ] boat sea ])) :props (>> 'weight 0.01))
    (trace-forward-nodes r :nodes '(bt) :choice 'weighted-random-choice)
    (show "r trace-end {}" (l2c (>> r 'trace-end)))
    (show "r {}" r)
    ;;compo-obj: (wal rof win dor) (trk cro crw) (fad fdy fye fil) (hul bow pop sal)
    ;;bg: 'sky 'lan 'sea
    (dotimes (i (length compo-objs))
      (dolist (bg '(sky lan sea))
	(let* ((compo-obj-ex nil) (bg-ex (obj2polygon (>> scene bg))) (in-out? nil) (touch? nil) (direction? nil))
	  (show "compo-obj: {} bg: {}" (nth i compo-objs) bg)
	  ;;(trace-forward-nodes r :nodes (list (nth i compo-objs)) :choice 'weighted-random-choice)
	  (setf compo-obj-ex (nth i component-names)) ;eg. house -> (wal rof win dor) 
	  (setf compo-obj-ex (convex-hull (apply #'append (mapcar (lambda (obj) (obj2polygon (>> scene obj))) compo-obj-ex)))) ;outline
	  (let ((size (abs (area-polygon compo-obj-ex)))) (dotimes (i 20) (train size-gng :input (list (list size 0)) :init-nodes 3)))
	  (setf in-out? (in-out compo-obj-ex bg-ex))
	  (show "in-out {}" in-out?)
	  (setf touch? (polygon0-touch-polygon1 compo-obj-ex bg-ex))
	  (show "touch {}" touch?)
	  (setf direction? (name-direction (centroid-of-polygon compo-obj-ex) (centroid-of-polygon bg-ex)))
	  (show "direction {}" direction?)
	  (show "compo-obj-ex {}" compo-obj-ex)
	  (add-edge r :nodes (list 'bt (list '[ in-out? (if touch? (length touch?) 0) direction? '] (nth i compo-objs) bg)) :props (>> 'weight 0.01))
	  ;;(show-polygons :polygons (list compo-obj-ex))
	  ))))
  
  (let ((sizes '()))
    (dolist (obj (hash-keys scene))
      (let ((size (abs (area-polygon (obj2polygon (>> scene obj))))))
	(dotimes (i 20) (when (not (member obj '(sce sky sea lan) :test 'equal)) (train size-gng :input (list (list size 0)) :init-nodes 3)))))
    (setf sizes (sort (mapcar (lambda (size) (car (>> size 'pos)))(hash-values (>> size-gng 'nodes))) #'<))
    (show "sizes {}" sizes)
    (dolist (obj (hash-keys scene))
      (let* ((name (join (list obj 'o))) (shape (>> scene `(,obj shape))) (direct (name-direction nil nil (>> scene `(,obj a))))
	     (size (abs (area-polygon (obj2polygon (>> scene obj)))))
	     (size-name nil)
	     (distan (mapcar (lambda (s) (abs (- s size))) sizes))
	     (min-distan (apply #'min distan))
	     (min-index (position min-distan distan)))
	(cond
	  ((= min-index 0) (setf size-name 'small))
	  ((= min-index 1) (setf size-name 'medium))
	  ((= min-index 2) (setf size-name 'large)))
	(add-edge r :nodes (list obj (list '[ name shape direct size-name '])) :props (>> 'weight 0.01)))))
  (show "relations r: {}" r)
  (show "run-node {}" (run-node r :node 'bt))
  (show "r trace-end {}" (l2c (>> r 'trace-end)))
  (show "trace-forward-nodes bt {}" (trace-forward-nodes r :nodes '(bt) :choice 'weighted-random-choice))
  (show "bt r trace-end {}" (l2c (>> r 'trace-end)))
  (show "size-gng nodes {}" (sort (mapcar (lambda (size) (car (>> size 'pos))) (hash-values (>> size-gng 'nodes))) #'<)))
;;(test-house-graph)

(defun find-relations (&optional (r (make-agent)) (scene (get-scene3)) (size-gng (make-gng)))
  (>> size-gng 'max-nodes 9)
  (init-relations :r r :scene scene)
  ;;(show "init-relations {}" (>> r 'edges))
  ;;add edge for terminal leaves including shape, direction and size  
  (let ((sizes (mapcar (lambda (obj) (abs (area-polygon (obj2polygon (>> scene obj))))) (hash-keys scene))))
    (dotimes (i 2000)
      (train size-gng :input (list (list (random-choice sizes) 0)) :init-nodes 9))
    (setf sizes (sort (mapcar (lambda (size) (car (>> size 'pos))) (hash-values (>> size-gng 'nodes))) #'<))
    (show "sizes {}" sizes)
    (dolist (obj (hash-keys scene))
      (let* (;;(name (join (list obj 'o)))
	      (shape (>> scene `(,obj shape)))
	      (direct (name-direction nil nil (>> scene `(,obj a))))
	      (size (abs (area-polygon (obj2polygon (>> scene obj)))))
	      (size-name nil)
	      (distan (mapcar (lambda (s) (abs (- s size))) sizes))
	      (min-distan (apply #'min distan))
	      (min-index (position min-distan distan)))
	(show "obj {} min-index {}" obj min-index)
	(cond
	  ((= min-index 0) (setf size-name 'ss))
	  ((= min-index 1) (setf size-name 'sm))
	  ((= min-index 2) (setf size-name 'sl))
	  ((= min-index 3) (setf size-name 'ms))
	  ((= min-index 4) (setf size-name 'mm))
	  ((= min-index 5) (setf size-name 'ml))
	  ((= min-index 6) (setf size-name 'ls))
	  ((= min-index 7) (setf size-name 'lm))
	  ((= min-index 8) (setf size-name 'll)))
	;;(add-edge r :nodes (list obj (c2l (list shape direct size-name))))
	(add-edge r :nodes (list obj (c2l (list shape direct 'medium))))
	(>> r `(nodes ,obj utter) (list (list 0.01 (random-word)))) ;; add utterance for terminal objects such as dor(door)
	)))
  (get-relations :r r :scene scene)
  ;;(show "get-relations {}" (>> r 'edges))
  (let* ((components (get-components :edges (>> r 'edges)))
	  (component-names (mapcar (lambda (item) (car item)) components))
	  (component-edges (mapcar (lambda (item) (second item)) components))
	  (compo-objs '(fish boat tree house))
	  (degrees (mapcar (lambda (component) (mapcar (lambda (obj) (node-degree r :node obj)) component)) component-names))
	  (areas (mapcar (lambda (component) (mapcar (lambda (obj) (abs (area-polygon (obj2polygon (>> scene obj))))) component)) component-names)))
    ;;(show "components {}" components)
    (show "component-names {}" component-names)
    (show "component-edges {}" component-edges)
    (show "degrees {}" degrees)
    (show "areas {}" areas)
    ;;add new edges for compo-objs like house
    (mapcar (lambda (co-obj compo-names compo-edges)
	      (add-edge r :nodes (list (list 'components co-obj) (append (list 'and) (mapcar (lambda (x) (car (>> r `(edges ,x nodes)))) compo-edges))))
	      (add-edge r :nodes (list 'compo-obj co-obj) :order? nil))
      '(fish boat tree house) component-names component-edges)
    (add-edge r :nodes '(fish (tria left medium)))
    (add-edge r :nodes '(boat (tria left medium)))
    (add-edge r :nodes '(tree (tria up medium)))
    (add-edge r :nodes '(house (tria up medium)))
    ;;compo-obj: (wal rof win dor) (trk cro crw) (fad fdy fye fil) (hul bow pop sal) ;;bg: 'sky 'lan 'sea
    (dotimes (i (length compo-objs))
      (dolist (bg '(lan sea))
	(let* ((compo-obj-ex nil) (bg-ex (obj2polygon (>> scene bg))) (in-out? nil) (touch? nil) (direction? nil))
	  (setf compo-obj-ex (nth i component-names)) ;eg. house -> (wal rof win dor)
	  (setf compo-obj-ex (convex-hull (apply #'append (mapcar (lambda (obj) (obj2polygon (>> scene obj))) compo-obj-ex)))) ;outline
	  ;;(let ((size (abs (area-polygon compo-obj-ex)))) (dotimes (i 20) (train size-gng :input (list (list size 0)) :init-nodes 9)))
	  (setf in-out? (in-out compo-obj-ex bg-ex))
	  ;;(setf touch? (polygon0-touch-polygon1 compo-obj-ex bg-ex))
	  (setf direction? (name-direction (centroid-of-polygon compo-obj-ex) (centroid-of-polygon bg-ex)))
	  (when (not (equal in-out? 'to))
	    ;;(add-edge r :nodes (list (join (list (nth i compo-objs) bg)) (c2l (list '[ in-out? direction? '] (nth i compo-objs) bg))) :order? t)
	    (add-edge r :nodes (list (join (list (nth i compo-objs) bg)) (c2l (list in-out? (nth i compo-objs) bg))) :order? t)
	    (add-edge r :nodes (list 'obj-bg (join (list (nth i compo-objs) bg))) :order? nil)))))
    ;; add utterance for compo-objects such as house
    (dolist (cobj compo-objs) (>> r `(nodes ,cobj utter) (list (list 0.01 (random-word)))))
    ;;add relations between sun which is not a compo-obj and sky
    (let* ((sun (obj2polygon (>> scene 'sun))) (sky (obj2polygon (>> scene 'sky)))
	    (in-out? (in-out sun sky))
	    (direction? (name-direction (centroid-of-polygon sun) (centroid-of-polygon sky))))
      ;;(add-edge r :nodes (list 'sun_sky (c2l (list '[ in-out? direction? '] 'sun 'sky))) :order? t)
      (add-edge r :nodes (list 'sun_sky (c2l (list in-out? 'sun 'sky))) :order? t)
      (add-edge r :nodes (list 'obj-bg 'sun_sky) :order? nil)))
  (dolist (k (hash-keys scene))
    (add-edge r :nodes (list (>> scene `(,k type)) k) :order? nil))
  
  ;;(show "relations edges: {}" (>> r 'edges))
  #| ;;demo test
  (show "run-node {}" (run-node r :node 'house_lan))
  (show "r trace-end {}" (l2c (>> r 'trace-end)))
  (trace-forward-nodes r :nodes '(house_lan) :choice 'weighted-random-choice :nonterminal? nil :level nil)
  (show "bt r trace-end {}" (l2c (>> r 'trace-end)))
  (trace-forward-nodes r :nodes '([ to [ down left ] ] fish sky) :choice 'weighted-random-choice :nonterminal? nil)
  (show "([ to [ down left ] ] fish sky) r trace-end {}" (l2c (>> r 'trace-end)))
  (show "size-gng nodes {}" (sort (mapcar (lambda (size) (car (>> size 'pos))) (hash-values (>> size-gng 'nodes))) #'<))
  (show "production: ([ to [ down left ] ] fish sky) -> {}" (production r :meaning '([ to [ down left ] ] fish sky)))
  (show "production: (c2l (zero (plus minus))) -> {}" (production r :meaning (c2l '(zero (plus minus)))))
  (show "parsing: (hapi ku hapi xo movi gage gage vita moca) -> {}" (parsing r :utters '("hapi" "ku" "hapi" "xo" "movi" "gage" "gage" "vita" "moca") :bintree t))
  (show "(cosine-distan fad fdy) {}" (cosine-distan (>> r `(nodes fad hrr)) (>> r `(nodes fdy hrr))))
  (show "(cosine-distan fad fye) {}" (cosine-distan (>> r `(nodes fad hrr)) (>> r `(nodes fye hrr))))
  (show "(cosine-distan house tree) {}" (cosine-distan (>> r `(nodes house hrr)) (>> r `(nodes tree hrr))))
  (show "(cosine-distan fish boat) {}" (cosine-distan (>> r `(nodes fish hrr)) (>> r `(nodes boat hrr))))
  (show "(cosine-distan fish house) {}" (cosine-distan (>> r `(nodes fish hrr)) (>> r `(nodes house hrr))))
  (show "(cosine-distan tree_lan house_lan) {}" (cosine-distan (>> r `(nodes tree_lan hrr)) (>> r `(nodes house_lan hrr))))
  (show "(cosine-distan tree_lan boat_sea) {}" (cosine-distan (>> r `(nodes tree_lan hrr)) (>> r `(nodes boat_sea hrr))))
  (show "(cosine-distan rof_wal cro_trk) {}" (cosine-distan (>> r `(nodes rof_wal hrr)) (>> r `(nodes cro_trk hrr))))
  (show "(cosine-distan rof_wal fye_fad) {}" (cosine-distan (>> r `(nodes rof_wal hrr)) (>> r `(nodes fye_fad hrr))))
  (show "(cosine-distan sun fye) {}" (cosine-distan (>> r `(nodes sun hrr)) (>> r `(nodes fye hrr))))
  (trace-forward-nodes r :nodes '(sun) :choice 'weighted-random-choice :nonterminal? nil :level nil)
  (show "sun: {}" (l2c (>> r 'trace-end)))
  (trace-forward-nodes r :nodes '(fye) :choice 'weighted-random-choice :nonterminal? nil :level nil)
  (show "fye: {}" (l2c (>> r 'trace-end)))
  (show "(cosine-distan sun rof) {}" (cosine-distan (>> r `(nodes sun hrr)) (>> r `(nodes rof hrr))))  
  (trace-forward-nodes r :nodes '(rof) :choice 'weighted-random-choice :nonterminal? nil :level nil)
  (show "rof: {}" (l2c (>> r 'trace-end)))
  (show "(cosine-distan sun house) {}" (cosine-distan (>> r `(nodes sun hrr)) (>> r `(nodes house hrr))))|#
  (trace-forward-nodes r :nodes '(house) :choice 'weighted-random-choice :nonterminal? nil :level 10)
  (show "house: {}" (l2c (>> r 'trace-end)))
  (show "house: {}" (l2c (trace-forward-nodes r :nodes '(house))))
  (show "components house: {}" (l2c (trace-forward-nodes r :nodes '(components house))))
  (show "house level 0 -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(house))) :level 0)))
  (show "trk level 0-> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(trk))) :level 0)))
  (show "elaborate trk-> <- {}"(l2c (trace-forward-nodes r :nodes '(relation obj trk))))
  (show "scale up(down) trk-> <- {}"(l2c (mapcar (lambda (feature)
					  (if (equal feature 'medium)
					    (let ((size (trace-forward-nodes r :nodes '(size))))
					      (loop do (setf size (trace-forward-nodes r :nodes '(size))) while (equal size 'medium)) size)
					    feature))
				  (trace-forward-nodes r :nodes '(trk)))))
  (show "scale up(down) house-> <- {}"(l2c (mapcar (lambda (feature)
					  (if (equal feature 'medium)
					    (let ((size (trace-forward-nodes r :nodes '(size))))
					      (loop do (setf size (trace-forward-nodes r :nodes '(size))) while (equal size 'medium)) size)
					    feature))
				  (trace-forward-nodes r :nodes '(house)))))
  (show "sky level 0 -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(sky))) :level 0)))
  (show "(up left) -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(up left))))))
  (show "(elaborate obj) -> {}"(l2c (trace-forward-nodes r :nodes '(elaborate obj))))
  (show "(tria up medium) level 0 -> {}"(l2c (trace-backward-nodes r :nodes '(tria up medium) :nonterminal? t :level 0)))
  (show "obj-bg -> {}" (l2c (trace-forward-nodes r :nodes '(obj-bg) :nonterminal? t)))
  (show "obj-bg relations {}" (mapcar (lambda (edge) (trace-forward-nodes r :nodes (list (second (>> r `(edges ,edge nodes)))) :level 0)) (get-out-edges r :node 'obj-bg)))
  (show "----------------------------------------")
  (show "obj -> {}"(l2c (trace-forward-nodes r :nodes '(obj) :level nil)))
  (show "compo-obj:level 1 -> {}"(l2c (trace-forward-nodes r :nodes '(compo-obj) :level 1)))
  (show "pair-obj:level 1 -> {}"(l2c (trace-forward-nodes r :nodes '(pair-obj) :level 1)))
  (show "obj-bg:level 1 -> {}" (l2c (trace-forward-nodes r :nodes '(obj-bg) :nonterminal? t :level 1)))
  (show "fish:level 0 <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fish))) :level 0)))
  (show "fish <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fish))) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium) gate 23 <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria up medium) :gate-edges '())) :gate-edges '(23) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium)(-35 -115 23 20 14 8 11 15 114 34) -> {}" (trace-edges r :nodes '(tria up medium) :path '(-35 -115 23 20 14 8 11 15 114 34) :gradient-mutate 0))
  (show "(in fish sea)(-83 87) -> {}" (trace-edges r :nodes '(in fish sea) :path '(-83 87)));result should be (in tree sea)
  (show "in <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(in))))))
  (show "right <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(right))))))
  (show "tria <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria))))))
  (show "small <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(small))))))
  (show "{}" (mapcar (lambda (edge) (second (>> r `(edges ,edge nodes)))) (get-out-edges r :node 'compo-obj)))
  (show "fdy gate 23 <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fdy))) :clean-path? nil :gate-edges '(23))) (>> r 'path))
  (show "fdy <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fdy))) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium) <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria up medium))) :gate-edges '() :clean-path? nil)) (>> r 'path))
  r) 
;;(find-relations)

;;|---------------------+---------+-------+----------|
;;| size-name           | scale   |  size | example  |
;;|---------------------+---------+-------+----------|
;;| (very (very large)) | 1       | 10000 | scene    |
;;| (very large)        | 1/5     |  2000 |          |
;;| large               | 1/25    |   400 | wall     |
;;| medium              | 1/125   |    80 |          |
;;| small               | 1/625   |    16 |          |
;;| (very small)        | 1/3125  |  16/5 |          |
;;| (very (very small)) | 1/15625 | 16/25 | fish-eye |
;;|---------------------+---------+-------+----------|
(defun name-size (&key (size 0.5) (size0 1) (scale 2))
  (let ((i 0) (size-new size0) (distan0 nil) (distan1 nil) (size-name nil))
    (if (< size size0)
      (loop do
	(setf distan0 (abs (- size size-new)))
	(setf size-new (/ size-new scale))
	(setf distan1 (abs (- size size-new)))
	(decf i)
	while (< distan1 distan0))
      (loop do
	(setf distan0 (abs (- size size-new)))
	(setf size-new (* size-new scale))
	(setf distan1 (abs (- size size-new)))
	(incf i)
	while (< distan1 distan0)))
    (if (< i 0)
      (setf i (+ i 1))
      (setf i (- i 1)))
    (cond
      ((= i 0) (setf size-name 'medium))
      ((= i -1) (setf size-name 'small))
      ((= i 1) (setf size-name 'large))
      ((< i -1)
	(setf size-name 'small)
	(dotimes (j (- (abs i) 1))
	  (setf size-name (list 'very size-name))))
      ((> i 1)
	(setf size-name 'large)
	(dotimes (j (- i 1))
	  (setf size-name (list 'very size-name)))))
    size-name))
;;(name-size :size 0.5 :size0 1 :scale 2)
;;(sizes '(16/25 16/5 16 80 400 2000 10000)) 
;;(name-size :size 0.5 :size0 80 :scale 5)
;;(get-size :size-name (name-size :size 10000 :size0 80 :scale 5) :size0 80 :scale 5)

(defun get-size0 (&key (size-name '(very (very (* size0 scale)))) (size0 1) (scale 2) (start? t))
  (let ((start_ start?))
    (when start? (setf start? nil))
    (when (/= 3 (length size-name))
      (let ((oper (car size-name))
	     (var (second size-name)))
	(if (= 3 (length var)) ;;eg. (* size0 2)
	  (setf size-name (list (car var) var (car (last var))))
	  (progn
	    (setf var (get-size0 :size-name var :size0 size0 :scale scale :start? start?))
	    (setf size-name (get-size0 :size-name (list oper var) :size0 size0 :scale scale :start? start?))))))
    (cond
      ((and size0 scale start_)
	(progn
	  (setf size-name (replace* :item 'size0 :of size-name :with size0))
	  (setf size-name (replace* :item 'scale :of size-name :with scale))
	  (eval size-name)))
      ((and size0 start_)
	(replace* :item 'size0 :of size-name :with size0))
      ((and scale start_)
	(replace* :item 'scale :of size-name :with scale))
      (t size-name))))
;;(get-size0)
;;(show "{}" (get-size0 :size-name '(very (very (very (/ size0 2)))) :size0 nil)) ;;(/ (/ (/ (/ size0 2) 2) 2) 2)
;;(show "{}" (get-size0 :size-name '(very (very (very (/ size0 2))))))   ;;1/16
;;(show "{}" (get-size0 :size-name '(very (very (very (/ size0 2)))) :size0 2)) ;;1/8
;;(get-size0 :size-name '(* size0 2))

(defun get-size (&key (size-name '(very (very small))) (size0 1) (scale 2) (start? t))
  (if (listp size-name)
    (cond
      ((member 'small (c2l size-name)) (setf size-name (replace* :item 'small :of size-name :with '(/ size0 scale))))
      ((member 'large (c2l size-name)) (setf size-name (replace* :item 'large :of size-name :with '(* size0 scale))))
      ((member 'medium (c2l size-name)) (setf size-name (replace* :item 'medium :of size-name :with '(* size0 1)))))
    (cond
      ((equal 'small size-name) (setf size-name '(/ size0 scale)))
      ((equal 'large size-name) (setf size-name '(* size0 scale)))
      ((equal 'medium size-name) (setf size-name '(* size0 1)))))
  (get-size0 :size-name size-name :size0 size0 :scale scale :start? start?))
;;(get-size :size-name '(very (very (very small))) :size0 1 :scale 2)

(defun find-relations1 (&optional (r (make-agent)) (scene (get-scene3)) (size-gng (make-gng)))
  (init-relations :r r :scene scene)
  ;;(show "init-relations {}" (>> r 'edges))
  ;;add edge for terminal leaves including shape, direction and size  
  (let ((sizes '(16/25 16/5 16 80 400 2000 10000)))
    (show "sizes {}" sizes)
    (dolist (obj (hash-keys scene))
      (let* (;;(name (join (list obj 'o)))
	      (shape (>> scene `(,obj shape)))
	      (direct (name-direction nil nil (>> scene `(,obj a))))
	      (size (abs (area-polygon (obj2polygon (>> scene obj)))))
	      (size-name nil)
	      (distan (mapcar (lambda (s) (abs (- s size))) sizes))
	      (min-distan (apply #'min distan))
	      (min-index (position min-distan distan)))
	(show "obj {} min-index {}" obj min-index)
	(cond
	  ((= min-index 0) (setf size-name '(very (very small))))
	  ((= min-index 1) (setf size-name '(very small)))
	  ((= min-index 2) (setf size-name 'small))
	  ((= min-index 3) (setf size-name 'medium))
	  ((= min-index 4) (setf size-name 'large))
	  ((= min-index 5) (setf size-name '(very large)))
	  ((= min-index 6) (setf size-name '(very (very large))))
	  )
	(add-edge r :nodes (list obj (c2l (list shape direct 'medium size-name))))
	(>> r `(nodes ,obj utter) (list (list 0.01 (random-word)))) ;; add utterance for terminal objects such as dor(door)
	))
    (get-relations :r r :scene scene)
    ;;(show "get-relations {}" (>> r 'edges))
    (let* ((components (get-components :edges (>> r 'edges)))
	    (component-names (mapcar (lambda (item) (car item)) components))
	    (component-edges (mapcar (lambda (item) (second item)) components))
	    (compo-objs '(fish boat tree house))
	    (degrees (mapcar (lambda (component) (mapcar (lambda (obj) (node-degree r :node obj)) component)) component-names))
	    (areas (mapcar (lambda (component) (mapcar (lambda (obj) (abs (area-polygon (obj2polygon (>> scene obj))))) component)) component-names))
	    (area (mapcar (lambda (component) (apply #'+ (mapcar (lambda (obj) (if (member obj '(fye win dor)) 0 (abs (area-polygon (obj2polygon (>> scene obj)))))) component))) component-names))	  
	    )
      ;;(show "components {}" components)
      (show "component-names {}" component-names)
      (show "component-edges {}" component-edges)
      (show "degrees {}" degrees)
      (show "areas {}" areas)
      (show "area {}" area)
      ;;add new edges for compo-objs like house
      (mapcar (lambda (co-obj compo-names compo-edges)
		(add-edge r :nodes (list (list 'components co-obj) (append (list 'and) (mapcar (lambda (x) (car (>> r `(edges ,x nodes)))) compo-edges))))
		(add-edge r :nodes (list 'compo-obj co-obj) :order? nil))
	'(fish boat tree house) component-names component-edges)
      (dotimes (i (length area))
	(let* ((distan (mapcar (lambda (s) (abs (- s (nth i area)))) sizes))
		(size-name nil)
		(min-distan (apply #'min distan))
		(min-index (position min-distan distan)))
	  (cond
	    ((= min-index 0) (setf size-name '(very (very small))))
	    ((= min-index 1) (setf size-name '(very small)))
	    ((= min-index 2) (setf size-name 'small))
	    ((= min-index 3) (setf size-name 'medium))
	    ((= min-index 4) (setf size-name 'large))
	    ((= min-index 5) (setf size-name '(very large)))
	    ((= min-index 6) (setf size-name '(very (very large))))
	    )
	  (cond
	    ((= i 0) (add-edge r :nodes (list 'fish  (list 'tria 'left 'medium size-name))))
	    ((= i 1) (add-edge r :nodes (list 'boat  (list 'tria 'left 'medium size-name))))
	    ((= i 2) (add-edge r :nodes (list 'tree  (list 'tria 'up   'medium size-name))))
	    ((= i 3) (add-edge r :nodes (list 'house (list 'tria 'up   'medium size-name))))
	    )))
      ;;compo-obj: (wal rof win dor) (trk cro crw) (fad fdy fye fil) (hul bow pop sal) ;;bg: 'sky 'lan 'sea
      (dotimes (i (length compo-objs))
	(dolist (bg '(lan sea))
	  (let* ((compo-obj-ex nil) (bg-ex (obj2polygon (>> scene bg))) (in-out? nil) (touch? nil) (direction? nil))
	    (setf compo-obj-ex (nth i component-names)) ;eg. house -> (wal rof win dor)
	    (setf compo-obj-ex (convex-hull (apply #'append (mapcar (lambda (obj) (obj2polygon (>> scene obj))) compo-obj-ex)))) ;outline
	    (setf in-out? (in-out compo-obj-ex bg-ex))
	    ;;(setf touch? (polygon0-touch-polygon1 compo-obj-ex bg-ex))
	    (setf direction? (name-direction (centroid-of-polygon compo-obj-ex) (centroid-of-polygon bg-ex)))
	    (when (not (equal in-out? 'to))
	      ;;(add-edge r :nodes (list (join (list (nth i compo-objs) bg)) (c2l (list '[ in-out? direction? '] (nth i compo-objs) bg))) :order? t)
	      (add-edge r :nodes (list (join (list (nth i compo-objs) bg)) (c2l (list in-out? (nth i compo-objs) bg))) :order? t)
	      (add-edge r :nodes (list 'obj-bg (join (list (nth i compo-objs) bg))) :order? nil)))))
      ;; add utterance for compo-objects such as house
      (dolist (cobj compo-objs) (>> r `(nodes ,cobj utter) (list (list 0.01 (random-word)))))
      ;;add relations between sun which is not a compo-obj and sky
      (let* ((sun (obj2polygon (>> scene 'sun))) (sky (obj2polygon (>> scene 'sky)))
	      (in-out? (in-out sun sky))
	      (direction? (name-direction (centroid-of-polygon sun) (centroid-of-polygon sky))))
	;;(add-edge r :nodes (list 'sun_sky (c2l (list '[ in-out? direction? '] 'sun 'sky))) :order? t)
	(add-edge r :nodes (list 'sun_sky (c2l (list in-out? 'sun 'sky))) :order? t)
	(add-edge r :nodes (list 'obj-bg 'sun_sky) :order? nil))))
  (dolist (k (hash-keys scene))
    (add-edge r :nodes (list (>> scene `(,k type)) k) :order? nil))
  
  (trace-forward-nodes r :nodes '(house) :choice 'weighted-random-choice :nonterminal? nil :level 10)
  (show "house: {}" (l2c (>> r 'trace-end)))
  (show "house: {}" (l2c (trace-forward-nodes r :nodes '(house))))
  (show "components house: {}" (l2c (trace-forward-nodes r :nodes '(components house))))
  (show "house level 0 -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(house))) :level 0)))
  (show "trk level 0-> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(trk))) :level 0)))
  (show "elaborate trk-> <- {}"(l2c (trace-forward-nodes r :nodes '(relation obj trk))))
  (show "scale up(down) trk-> <- {}"(l2c (mapcar (lambda (feature)
						   (if (equal feature 'medium)
						     (let ((size (trace-forward-nodes r :nodes '(size))))
						       (loop do (setf size (trace-forward-nodes r :nodes '(size))) while (equal size 'medium)) size)
						     feature))
					   (trace-forward-nodes r :nodes '(trk)))))
  (show "scale up(down) house-> <- {}"(l2c (mapcar (lambda (feature)
						     (if (equal feature 'medium)
						       (let ((size (trace-forward-nodes r :nodes '(size))))
							 (loop do (setf size (trace-forward-nodes r :nodes '(size))) while (equal size 'medium)) size)
						       feature))
					     (trace-forward-nodes r :nodes '(house)))))
  (show "sky level 0 -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(sky))) :level 0)))
  (show "(up left) -> <- {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(up left))))))
  (show "(elaborate obj) -> {}"(l2c (trace-forward-nodes r :nodes '(elaborate obj))))
  (show "(tria up medium) level 0 -> {}"(l2c (trace-backward-nodes r :nodes '(tria up medium) :nonterminal? t :level 0)))
  (show "obj-bg -> {}" (l2c (trace-forward-nodes r :nodes '(obj-bg) :nonterminal? t)))
  (show "obj-bg relations {}" (mapcar (lambda (edge) (trace-forward-nodes r :nodes (list (second (>> r `(edges ,edge nodes)))) :level 0)) (get-out-edges r :node 'obj-bg)))
  (show "----------------------------------------")
  (show "obj -> {}"(l2c (trace-forward-nodes r :nodes '(obj) :level nil)))
  (show "compo-obj:level 1 -> {}"(l2c (trace-forward-nodes r :nodes '(compo-obj) :level 1)))
  (show "pair-obj:level 1 -> {}"(l2c (trace-forward-nodes r :nodes '(pair-obj) :level 1)))
  (show "obj-bg:level 1 -> {}" (l2c (trace-forward-nodes r :nodes '(obj-bg) :nonterminal? t :level 1)))
  (show "fish:level 0 <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fish))) :level 0)))
  (show "fish <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fish))) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium) gate 23 <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria up medium) :gate-edges '())) :gate-edges '(23) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium)(-35 -115 23 20 14 8 11 15 114 34) -> {}" (trace-edges r :nodes '(tria up medium) :path '(-35 -115 23 20 14 8 11 15 114 34) :gradient-mutate 0))
  (show "(in fish sea)(-83 87) -> {}" (trace-edges r :nodes '(in fish sea) :path '(-83 87)));result should be (in tree sea)
  (show "in <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(in))))))
  (show "right <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(right))))))
  (show "tria <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria))))))
  (show "small <--> {}"(l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(small))))))
  (show "{}" (mapcar (lambda (edge) (second (>> r `(edges ,edge nodes)))) (get-out-edges r :node 'compo-obj)))
  (show "fdy gate 23 <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fdy))) :clean-path? nil :gate-edges '(23))) (>> r 'path))
  (show "fdy <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(fdy))) :clean-path? nil)) (>> r 'path))
  (show "(tria up medium) <--> {} {}" (l2c (trace-forward-nodes r :nodes (list (trace-backward-nodes r :nodes '(tria up medium))) :gate-edges '() :clean-path? nil)) (>> r 'path))
  r)
;;(show "{}" (find-relations1))

#|
(bt (in left) fish (fad (tria left small) fdy (tria right small) fye (elli right small) fil (tria left small)) sea (rect right large))
|#

(defun test-house-bt ()
  (defparameter bt (make-graph))
  (defparameter scene (get-scene3))
  ;;(add-edge bt :nodes '(([ d e ]) ([ a b c ])) :props (>> 'weight 0.01))
  (add-edge bt :nodes '(bin-tree ([ oper obj obj ])))
  (add-edge bt :nodes '(obj bin-tree) :props (>> 'max-depth 2 'depth 0));if max-depth=0, this edge will not be used.
  (dolist (k (hash-keys scene))
    (add-edge bt :nodes `(name ,k)))
  (dolist (k '(elli rect tria))
    (add-edge bt :nodes `(shape ,k)))
  (dolist (k '(up down left right center)) (add-edge bt :nodes `(direct ,k)))
  (add-edge bt :nodes '(direct ([ direct direct ])) :props (>> 'max-depth 2 'depth 0))
  (dolist (k '(in contain intersect out))
    (add-edge bt :nodes `(relate ,k)))
  (dolist (k '(touched untouched))
    (add-edge bt :nodes `(touch ,k)))
  (dolist (k '(small medium large))
    (add-edge bt :nodes `(size ,k)))
  (add-edge bt :nodes '(size ([ very size ])) :props (>> 'max-depth 2 'depth 0))
  ;;(>> bt `(nodes very fun) '(random 1000))
  ;;(>> bt `(nodes very output) 100)
  (add-edge bt :nodes '(oper ([ relate touch direct ])))   
  (add-edge bt :nodes '(obj ([ name shape direct size ])))
  (show "(trace-forward-nodes bt :nodes '(bin-tree)) {}" (trace-forward-nodes bt :nodes '(bin-tree) :choice 'weighted-random-choice))
  (show "bt: {}" bt)
  (show "(>> bt 'trace-end): {}" (car (l2c (>> bt 'trace-end))))

  (defparameter bt-boat (make-graph))
  (add-edge bt-boat :nodes '(bin-tree ([ on sal boat ])))
  (add-edge bt-boat :nodes '(sal bin-tree) :props (>> 'max-depth 3 'depth 0))
  (add-edge bt-boat :nodes '(sal sail));terminal should be set. Otherwise, it will continue cycling.
  (show "(trace-forward-nodes bt-boat :nodes '(bin-tree) :choice 'weighted-random-choice)")
  (trace-forward-nodes bt-boat :nodes '([ on sal boat ] bin-tree) :choice 'weighted-random-choice)
  (show "bt: {}" bt)
  (show "(>> bt-boat 'trace-end): {} {}" (l2c (>> bt-boat 'trace-end)) (>> bt-boat 'path))
  (trace-backward-nodes bt-boat :nodes '( on boat [ on [ on sal boat ] boat ]))
  (show "(>> bt-boat 'trace-end): {} {}" (l2c (>> bt-boat 'trace-end)) (>> bt-boat 'path))
  )
;;(test-house-bt)

(defun test ()
  (defparameter g (make-graph))
  (add-edge g :nodes '(in-sun-sky (in sun sky)) :order? t)
  (add-edge g :nodes '(in-sky-sun (in sky sun)) :order? t)
  (add-edge g :nodes '(in-bird-sky (in bird sky)) :order? t)
  (add-edge g :nodes '(on-tree-land (on tree land)) :order? t)
  (show "{}" (>> g 'edges))
  (show "(cosine-distan in-sun-sky in-sky-sun) {}" (cosine-distan (>> g `(nodes in-sun-sky hrr)) (>> g `(nodes in-sky-sun hrr))))
  (show "(cosine-distan in-sun-sky in-bird-sky) {}" (cosine-distan (>> g `(nodes in-sun-sky hrr)) (>> g `(nodes in-bird-sky hrr))))
  (show "(cosine-distan in-sun-sky on-tree-land) {}" (cosine-distan (>> g `(nodes in-sun-sky hrr)) (>> g `(nodes on-tree-land hrr))))
  )
;;(test)

(defun test-graph2 ()
  (let ((g (make-graph)))
    (add-edge g :nodes '(house (on roof wall-obj)))
    (add-edge g :nodes '(wall-obj (in win-door wall)))
    (add-edge g :nodes '(win-door (out window door)))
    (trace-forward-nodes g :nodes '(house))
    (show "trace-end {} {}" (>> g 'trace-end) (>> g 'path))
    (trace-backward-nodes g :nodes '([ ON ROOF [ IN [ OUT WINDOW DOOR ] WALL ] ]))
    (show "trace-end {} {}" (>> g 'trace-end) (>> g 'path))
    ;;(show "{}" g)
    ))
;;(test-graph2)

(defun trace-fd (g &key (start 'tree) (choice-reverse? nil) (level nil)) ;trace-forward
  (let ((result start) (terminal? t) (expans '()))
    (when (or (null level) (> level 0))
      (when (and (not (null level)) (> level 0)) (setf level (- level 1)))
      (dolist (k (hash-keys (>> g 'edges)))
	(when (and (equalp start (car (s2l k))) (member 'expan (hash-keys (>> g `(edges ,k))) :test 'equal))
	  (push (list (>> g `(edges ,k weight)) k) expans);eg.'(tree_[_crown_trk_] tree_[_crw_trk_])
	  (when terminal? (setf terminal? nil)))
	(when (equalp start (s2l k));eg.crown_trk
	  (setf result (append (list (cdr (weighted-random-choice (>> g `(edges ,k feature))))) (mapcar (lambda (x) (trace-fd g :start x :choice-reverse? choice-reverse? :level level)) (s2l k))))
	  (setf terminal? nil)
	  (return))
	(when (and (listp start) (member (s2l k) start :test 'equalp))
	  (setf result (mapcar (lambda (x) (trace-fd g :start x :choice-reverse? choice-reverse? :level level)) start))
	  (setf terminal? nil)
	  (return)))
      (when expans;eg.'(tree_[_crown_trk_] tree_[_crw_trk_]) -> tree_[_crw_trk_]
	(let ((k (second (weighted-random-choice expans :reverse? choice-reverse?))))
	  (setf result (trace-fd g :start (second (s2l k)) :choice-reverse? choice-reverse? :level level))))
      (when terminal?;eg.trk
	;;(show "start {}" start)
	(if (member start (hash-keys (>> g 'nodes)) :test 'equal)
	  (progn
	    ;;(show "(cdr (>> g `(nodes ,start feature))) {}" (cdr (weighted-random-choice (>> g `(nodes ,start feature)))))
	    (setf result (append (list start) (cdr (weighted-random-choice (>> g `(nodes ,start feature)))))))
	  (if (listp start)
	    (if (member '{ start :test 'equal)
	      (progn
		(setf result (eval-expan :expan (c2l start)))
		(when (= (length result) 1) (setf result (car result))))
	      (setf result (mapcar (lambda (x) (trace-fd g :start x :choice-reverse? choice-reverse? :level level)) start)))
	    (setf result start)))))
    result))

(defun trace-bk (g &optional (start 'tree)) ;trace-backward
  (mapcar (lambda (x) (s2l x)) (hash-keys (>> g 'edges))))

#|
>> scale "very" (house big) -> (house very big) roof -> (triangle big) -> (triangle (big very))

elaboration
>> breadth roof -> (triangle red) -> (triangle red wood) 
>> depth eg, house -> (in house house) one more level

distinguish replacing oper from replacing leaves
>> hierarchical weight: eg, (oper obj obj) "oper (car)" is higher than "obj obj (cdr)", firstly randomly interleave all leaves (obj obj) on the same level, then weightedly interleave operator "oper" (2/3) with the interleaved leaves (total 1/3). 

;;distance 0 near(1) middle(2) far(3)
;;topological relation in(-2) tin(-1) int(0) on(1) to(2)
;;orientation angle [-1, 1];;up 1/2 down -1/2 right 0 left 1(-1)
;;size (max min)
;;the complexity of a design (a list of s-expressions) <-- max-depth, max-breadth
;;;e.g.((on left) (rectangle up medium) (triangle right small))

;;on house land -> in house sea
;;int boat sea -> in boat sea
;;in fish sea 

;;distance 0 near(1) middle(2) far(3)
;;topological relation in(-2) tin(-1) int(0) on(1) to(2)
;;orientation angle [-1, 1];;up 1/2 down -1/2 right 0 left 1(-1)
;;size (max min)
;;the complexity of a design (a list of s-expressions) <-- max-depth, max-breadth
((on down) (rect right medium) (tria right small))
fish-eye -> (elli right medium) --> (elli right medium (very (very small)));the last one is golbal size while the second last one in local size
|#

;;;;distance range [0 1] --------------------------------------------

(defun distan-direct (&optional (a0 0) (a1 1/2))
  (let ((directs (>> 'up 1/2 'down -1/2 'right 0 'left 1 'up_left 3/4 'up_right 1/4 'down_right -1/4 'down_left -3/4))
	 (result nil))
    (show "distan-direct a0 {} a1 {}" a0 a1)
    (when (member (l2s a0) (hash-keys directs) :test 'equalp)
      (setf a0 (>> directs (l2s a0))))
    (when (member (l2s a1) (hash-keys directs) :test 'equalp)
      (setf a1 (>> directs (l2s a1))))
    (setf result (abs (- a0 a1)))
    (when (> result 1) ;eg. (abs (- (- 1) 1)) -> 2
      (setf result (- 2 result))) ;eg. 2 -> (- 2 2) -> 0
    result))
;;(distan-direct -3/4 1/2)
;;(distan-direct 'up '(up right))
;;(distan-direct 'up 'up_right)

(defun distan-topo (&optional (t0 'in) (t1 'to))
  (let ((topos (>> 'in -1/2 'tin -1/4 'int 0 'on 1/4 'to 1/2)))
    (abs (- (>> topos t0) (>> topos t1)))))
;;(distan-topo 'in 'tin)

(defun distan-size (&optional (s0 '(very (very large))) (s1 'small))
  (let ((sizes (>> 'very_[_very_small_] -1/2 'very_small -1/3 'small -1/6 'medium 0 'large 1/6 'very_large 1/3 'very_[_very_large_] 1/2)))
    (abs (- (>> sizes (l2s s0)) (>> sizes (l2s s1))))))
;;(distan-size '(very (very small)) '(very (very large)))

(defun distan-shape (&optional (s0 'tria) (s1 'rect))
  (let ((shapes (>> 'tria 0 'rect 0.3 'elli 0.7 'poly 1)))
    (abs (- (>> shapes (l2s s0)) (>> shapes (l2s s1))))))
;;(distan-shape 'tria 'poly)

(defun distan-obj (g &optional (obj0 'sal) (obj1 'hul))
  (show "distan-obj (cdr (weighted-random-choice (>> g `(nodes ,obj0 feature)))) {}" (cdr (weighted-random-choice (>> g `(nodes ,obj0 feature)))))
  (if (equal obj0 obj1)
    0
    (let* ((feature0 (cdr (weighted-random-choice (>> g `(nodes ,obj0 feature)))))
	    (feature1 (cdr (weighted-random-choice (>> g `(nodes ,obj1 feature)))))
	    (shape-dis (distan-shape (car feature0) (car feature1)))
	    (direct-dis (distan-direct (second feature0) (second feature1)))
	    (size-dis (distan-size (third feature0) (third feature1)))
	    (dis (/ (+ shape-dis direct-dis size-dis) 3)))
      ;;(show "dis {} shape-dis {} direct-dis {} size-dis {}" dis shape-dis direct-dis size-dis)
      dis)))

(defun distan-compo-obj (g &optional (obj0 'boat) (obj1 'tree))
  (if (equal obj0 obj1)
    0
    (progn 
      (setf obj0 (quantify (trace-fd g :start obj0)))
      (setf obj1 (quantify (trace-fd g :start obj1)))
      (let ((differs '()))
	(dotimes (i (length obj0))
	  (dotimes (j (length obj1))
	    (push (average (mapcar (lambda (x y) (abs (- x y))) (flatten (nth i obj0)) (flatten (nth j obj1)))) differs)))
	(average differs)))))

;;weight decided by area is added. But the result is similar with the above function without weight. only difference is that every result is a little less than that from the above function
(defun distan-compo-obj1 (g &optional (obj0 'boat) (obj1 'tree))
  (if (equal obj0 obj1)
    0
    (let ((compos0 (trace-fd g :start obj0 :level 1))
	   (compos1 (trace-fd g :start obj1 :level 1))
	   (area0 nil) (areas0 '())
	   (area1 nil) (areas1 '()))
      (dotimes (i (length compos0))
	(when (member (caar (trace-fd g :start (nth i compos0) :choice-reverse? nil)) '(in tin) :test 'equal)
	  (setf (nth i compos0) (cdr (nth i compos0)))))
      (setf area0 (apply #'+ (mapcar (lambda (x) (abs (area-polygon (obj2polygon (>> g `(nodes ,x)))))) (remove-duplicates (flatten compos0)))))
      (setf areas0 (mapcar (lambda (compo) (apply #'+ (mapcar (lambda (x) (abs (area-polygon (obj2polygon (>> g `(nodes ,x)))))) compo))) compos0))
      (let ((total (apply #'+ areas0))) (setf areas0 (mapcar (lambda (x) (/ x total)) areas0)))
      
      (dotimes (i (length compos1))
	(when (member (caar (trace-fd g :start (nth i compos1) :choice-reverse? nil)) '(in tin) :test 'equal)
	  (setf (nth i compos1) (cdr (nth i compos1)))))
      (setf area1 (apply #'+ (mapcar (lambda (x) (abs (area-polygon (obj2polygon (>> g `(nodes ,x)))))) (remove-duplicates (flatten compos1)))))
      (setf areas1 (mapcar (lambda (compo) (apply #'+ (mapcar (lambda (x) (abs (area-polygon (obj2polygon (>> g `(nodes ,x)))))) compo))) compos1))
      (let ((total (apply #'+ areas1))) (setf areas1 (mapcar (lambda (x) (/ x total)) areas1)))
      ;;(show "{} -> {} : area0 {} areas0 {}" obj0 compos0 area0 areas0)
      ;;(show "{} -> {} : area1 {} areas1 {}" obj1 compos1 area1 areas1) 
      
      (setf obj0 (quantify (trace-fd g :start obj0)))
      (setf obj1 (quantify (trace-fd g :start obj1)))
      (let ((differs '()))
	(dotimes (i (length obj0))
	  (let (sub-differs '())
	    (dotimes (j (length obj1))
	      (push (* (average (mapcar (lambda (x y) (abs (- x y))) (flatten (nth i obj0)) (flatten (nth j obj1)))) (nth j areas1)) sub-differs))
	    (push (* (apply #'+ sub-differs) (nth i areas0)) differs)))
	(apply #'+ differs)))))

(defun distan-elaborate (&key (obj '(rect right medium)) (elaboration '((on up) (tria up small) (rect right medium))))
  ;;obj '(rect right medium) -> '((tin right) (rect right medium) (rect right medium)) ;the direction of relations is the same as the direction of obj. the topo is always tin, obj0 is the same as obj1 which is the original obj. Then use this expanded obj to compare with the elaborated obj.
  (show "obj {}" obj) (show "elaboration {}" elaboration) ;;obj (hul rect right small)
  (setf obj (list (list 'tin (second obj)) obj obj)) ;;(second obj) is the direction of the object
  (show "expanded obj {}" obj)
  ;;(average (remove 0 (mapcar (lambda (x y) (abs (- x y))) (flatten (quantify obj)) (flatten (quantify elaboration)))))
  (average (mapcar (lambda (x y) (abs (- x y))) (flatten (quantify obj)) (flatten (quantify elaboration))))
  )
;;(show "{}" (distan-elaborate :obj '(rect right small) :elaboration '((in left) (elli (up left) (very (very small))) (rect right small))))

(defun distan-bg (g &optional (obj0 'sea) (obj1 'sky))
  (if (equal obj0 obj1)
    0
    (let* ((feature0 (cdr (weighted-random-choice (>> g `(nodes ,obj0 feature)))))
	    (feature1 (cdr (weighted-random-choice (>> g `(nodes ,obj1 feature)))))
	    (shape-dis (distan-shape (car feature0) (car feature1)))
	    (direct-dis (distan-direct (second feature0) (second feature1)))
	    (size-dis (distan-size (third feature0) (third feature1)))
	    (density-dis (distan-size (fourth feature0) (fourth feature1)))
	    (dis (/ (+ shape-dis direct-dis size-dis density-dis) 4)))
      (show "dis {} shape-dis {} direct-dis {} size-dis {} density-dis {}" dis shape-dis direct-dis size-dis density-dis)
      dis)))

(defun distan (g a b)
  (let ((directs (>> 'up 1/2 'down -1/2 'right 0 'left 1 'up_left 3/4 'up_right 1/4 'down_right -1/4 'down_left -3/4))
	 (topos (>> 'in -1/2 'tin -1/4 'int 0 'on 1/4 'to 1/2))
	 (sizes (>> 'very_[_very_small_] -1/2 'very_small -1/3 'small -1/6 'medium 0 'large 1/6 'very_large 1/3 'very_[_very_large_] 1/2))
	 (shapes (>> 'tria 0 'rect 0.3 'elli 0.7 'poly 1))
	 (objs (remove-if-not (lambda (x) (and (equal (>> g `(nodes ,x type)) 'obj) (not (equal x 'sun)))) (hash-keys (>> g 'nodes))))
	 (compo-objs (remove-if-not (lambda (x) (or (equal (>> g `(nodes ,x type)) 'compo-obj) (equal x 'sun))) (hash-keys (>> g 'nodes))))
	 (bgs (remove-if-not (lambda (x) (equal (>> g `(nodes ,x type)) 'bg)) (hash-keys (>> g 'nodes))))
	 )
    (cond
      ((member (l2s a) (hash-keys directs) :test 'equalp) (distan-direct a b))
      ((member (l2s a) (hash-keys topos) :test 'equalp) (distan-topo a b))
      ((member (l2s a) (hash-keys sizes) :test 'equalp) (distan-size a b))
      ((member (l2s a) (hash-keys shapes) :test 'equalp) (distan-shape a b))
      ((or (member (l2s a) objs :test 'equalp) (member (l2s b) objs :test 'equalp)) (distan-obj g a b))
      ((member (l2s a) compo-objs :test 'equalp) (distan-compo-obj g a b))
      ((member (l2s a) bgs :test 'equalp) (distan-bg g a b))
      ((member (l2s a) '([ ]) :test 'equalp) a)
      )
    ))
;;(distan g 'up '(up right))
;;(distan g 'up 'up_right)
;;(distan g 'in 'tin)
;;(distan g '(very (very small)) '(very (very large)))
;;(distan g 'tria 'poly)

(defun quantify (&optional (lst '(((on (up right)) (tria up (very (very small))) (tria up medium)) ((on up) (tria (up left) medium) (rect up medium)))))
  (let ((sub-lsts '((very [ very small ]) (very small) (very [ very large ]) (very large) (up left) (up right) (down left) (down right)))
	 (features (>> 'up 1/2 'down -1/2 'right 0 'left 1 'up_left 3/4 'up_right 1/4 'down_right -1/4 'down_left -3/4 'in -1 'tin -1/2 'int 0 'on 1/2 'to 1 'very_[_very_small_] -1 'very_small -2/3 'small -1/3 'medium 0 'large 1/3 'very_large 2/3 'very_[_very_large_] 1 'tria 0 'rect 0.3 'elli 0.7 'poly 1)))
    (setf lst (split (l2s lst)))
    (dolist (sl sub-lsts)
      (when (is-sub-list sl lst) (setf lst (replace-lst :part (append (list '[) sl (list '])) :of lst :with (list (l2s sl))))))
    (dolist (k (hash-keys features))
      (when (member k lst :test 'equal) (setf lst (replace-lst :part (list k) :of lst :with (list (>> features k)))))))
  (setf lst (remove-if-not (lambda (x) (or (numberp x) (member x '([ ]) :test 'equal))) lst))
  (l2c lst))
;;(flatten (quantify))
;;(max-depth (quantify))

(defun elaborate (g &key (obj 'fad) (distance-range '(0 1))) 
  (let ((sizes (>> 'very_[_very_small_] -1/2 'very_small -1/3 'small -1/6 'medium 0 'large 1/6 'very_large 1/3 'very_[_very_large_] 1/2))
	 (result (trace-fd g :start (list 'relations 'obj obj) :choice-reverse? nil))
	 (obj2exist? nil))
    (show "elaborate result {}" result)
    (when (listp (car (third result)))
      (setf (third result) (third (third result)))
      (setf obj2exist? t))
    (loop do
      (setf (fourth (second result)) (s2l (random-choice (hash-keys sizes))))
      while (> (>> sizes (l2s (fourth (second result)))) (>> sizes (l2s (fourth (third result))))))
    (let ((distance (distan-elaborate :obj (trace-fd g :start obj) :elaboration result))
	   (success? nil)
	   (new-weight 0.01))
      (if (and (not (null distance)) (< (car distance-range) distance (second distance-range)))
	(progn (setf success? t) (setf new-weight (strengthen :weight new-weight)))
	(setf new-weight (weaken :weight new-weight)))
      (show "new-weight {}" new-weight)
      (show "Distance between {} and its elaboration {} is {}" obj result distance)
      (show "elaborate add-node ...")
      (let ((new-node1 (car (second result)))
	     (new-value1 (cdr (second result))))
	(show "new-node1 {} new-value1 {}" new-node1 new-value1)
	(if (member new-node1 (hash-keys (>> g 'nodes)))
	  (let* ((feature (>> g `(nodes ,new-node1 feature)))
		  (feature-values (mapcar (lambda (x) (cdr x)) feature)))
	    (show "feature {} feature-values {}" feature feature-values)
	    (if (member new-value1 feature-values :test 'equalp)
	      (let* ((index (position new-value1 feature-values :test 'equalp))
		      (weight (car (nth index feature))))
		(if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
		(setf (car (nth index feature)) weight))  
	      (push (append (list new-weight) new-value1) feature))
	    (>> g `(nodes ,new-node1 feature) feature))
	  (add-node g :node new-node1 :props (>> 'feature (list (append (list new-weight) (cdr (second result)))) 'imagine t))))
      (let ((new-value2 (cdr (third result))))
	(show "new-value2 {}" new-value2)
	(if (null obj2exist?)
	  (let ((new-node2 (join (list (car (third result)) 2) :link "")))
	    (show "new-node2 {}" new-node2)
	    (add-node g :node new-node2 :props (>> 'feature (list (append (list new-weight) new-value2)) 'imagine t)))
	  (let* ((new-node2 (car (third result)))
		  (feature (>> g `(nodes ,new-node2 feature)))
		  (feature-values (mapcar (lambda (x) (cdr x)) feature)))
	    (show "new-node2 {}" new-node2)
	    (if (member new-value2 feature-values :test 'equalp)
	      (let* ((index (position new-value2 feature-values :test 'equalp))
		      (weight (car (nth index feature))))
		(if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
		(setf (car (nth index feature)) weight))
	      (push (append (list new-weight) new-value2) feature))
	    (>> g `(nodes ,new-node2 feature) feature))))
      (show "elaborate add-edge ...")
      (if (null obj2exist?)
	(progn
	  (add-edge g :edge (l2s (list obj (list (car (second result)) (join (list (car (third result)) 2) :link "")))) :props (>> 'expan t 'imagine t) :weight new-weight)
	  (add-edge g :edge (l2s (list (car (second result)) (join (list (car (third result)) 2) :link ""))) :props (>> 'feature (list (list new-weight (car (car result)) (second (car result)))) 'imagine t) :weight new-weight))
	(let ((new-edge (l2s (list (car (second result)) (car (third result)))))
	       (new-expan-edge (l2s (list obj (list (car (second result)) (car (third result))))))
	       (edges (hash-keys (>> g 'edges)))
	       (new-value (list (car (car result)) (second (car result)))))
	  (if (member new-expan-edge edges :test 'equalp)
	    (let ((weight (>> g `(edges ,new-expan-edge weight))))
	      (if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
	      (>> g `(edges ,new-expan-edge weight) weight))
	    (add-edge g :edge new-expan-edge :props (>> 'expan t 'imagine t) :weight new-weight))
	  (if (member new-edge edges :test 'equalp)
	    (let* ((feature (>> g `(edges ,new-edge feature)))
		    (values (mapcar (lambda (x) (cdr x)) feature)))
	      (if (member new-value values :test 'equalp)
		(let* ((index (position new-value values :test 'equalp))
			(weight (car (nth index feature))))
		  (if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
		  (setf (car (nth index feature)) weight))
		(push (append (list new-weight) new-value) feature))
	      (>> g `(edges ,new-edge feature) feature))
	    (add-edge g :edge new-edge :props (>> 'feature (list (append (list new-weight) new-value)) 'imagine t) :weight new-weight))
	  ))
      (list distance success?))))

(defun replace-items (g &key (start '(sal hul)) (distance-range '(0.1 1))) ;(start 'fad) (start '(boat sea))
  (let* ((directs '(up down right left up_left up_right down_right down_left))
	  (topos '(in tin int on))
	  (sizes '(very_[_very_small_] very_small small medium large very_large very_[_very_large_]))
	  (shapes '(tria rect elli poly))
	  (objs (remove-if-not (lambda (x) (and (equal (>> g `(nodes ,x type)) 'obj) (not (equal x 'sun)))) (hash-keys (>> g 'nodes))))
	  (compo-objs (remove-if-not (lambda (x) (or (equal (>> g `(nodes ,x type)) 'compo-obj) (equal x 'sun))) (hash-keys (>> g 'nodes))))
	  (bgs (remove-if-not (lambda (x) (equal (>> g `(nodes ,x type)) 'bg)) (hash-keys (>> g 'nodes))))
	  (candies (>> 'directs directs 'topos topos 'sizes sizes 'shapes shapes 'objs objs 'compo-objs compo-objs 'bgs bgs))
	  (candi (random-choice (hash-keys candies)))
	  (sub-lsts '((very (very small)) (very small) (very (very large)) (very large) (up left) (up right) (down left) (down right)))
	  (refer nil)
	  (design nil)
	  )
    (if (symbolp start) 
      (setf refer (append (list start) (cdr (weighted-random-choice (>> g `(nodes ,start feature))))))
      (setf refer (trace-fd g :start start :choice-reverse? nil :level 1)))
    ;;(show "objs {}" objs)
    ;;(show "compo-objs {}" compo-objs)
    ;;(show "bgs {}" bgs)
    (show "start: {} refer before before before:  {}" start refer)
    (setf refer (mapcar (lambda (x) (l2s x)) refer)) ;;(mapcar (lambda (x) (l2s x)) '(fad tria left (very (very small)))) ->'(elli up very_[_very_small_]) 
    (dolist (sl sub-lsts)
      (when (is-sub-list sl refer) (setf refer (replace-lst :part sl :of refer :with (list (l2s sl))))))
    (show "refer before before:  {}" refer)
    (when (symbolp start) (setf refer (cdr refer)))
    (show "refer before: {}" refer)
    (loop do
      (setf candi (random-choice (hash-keys candies)))
      while (null (intersect (>> candies candi) refer)))
    (let ((part (list (random-choice (intersect (>> candies candi) refer))))
	   (with (list (random-choice (>> candies candi)))))
      (loop do
	(setf with (list (random-choice (>> candies candi))))
	while (equalp part with))
      ;;(show "part {}" part)
      ;;(show "with {}" with)
      (setf design (replace-lst :part part :of refer :with with)))
    (show "refer {}" refer)
    (show "design {}" design)
    
    ;;(s2l (join design))
    (let ((distance (car (remove-if (lambda (x) (= x 0)) (flatten (l2c (mapcar (lambda (x y) (distan g x y)) (flatten refer) (flatten design)))))))
	   (success? nil)
	   (new-weight 0.01))
      (show "distan {}" distance)
      (if (and (not (null distance)) (< (car distance-range) distance (second distance-range)))
	(progn (setf success? t) (setf new-weight (strengthen :weight new-weight)))
	(setf new-weight (weaken :weight new-weight)))
      (if (listp start)
	(let ((edge-name (l2s (cdr design))) ;eg. (start '(sal hul))  
	       (new-feature (append (list new-weight) (s2l (car design))))) ;eg. (s2l (car '(int_[_up_left_] boat lan)))
	  (if (member edge-name (hash-keys (>> g 'edges)) :test 'equal)
	    (let* ((feature (>> g (list 'edges edge-name 'feature)))
		    (feature-values (mapcar (lambda (x) (cdr x)) feature)))
	      (if (member (cdr new-feature) feature-values :test 'equalp)
		(let* ((index (position (cdr new-feature) feature-values :test 'equalp))
			(weight (car (nth index feature))))
		  (if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
		  (setf (car (nth index feature)) weight))
		(push new-feature feature))
	      (>> g (list 'edges edge-name 'feature) feature))
	    (add-edge g :edge edge-name :props (>> 'feature (list new-feature) 'imagine t) :weight new-weight)))
	(let* ((feature (>> g (list 'nodes start 'feature))) ;eg. (start 'fad)
		(feature-values (mapcar (lambda (x) (cdr x)) feature))
		(new-feature (append (list new-weight) (mapcar (lambda (x) (let ((item (s2l x))) (if (= (length item) 1) (car item) item))) design)))) ;;eg.(mapcar (lambda (x) (let ((item (s2l x))) (if (= (length item) 1) (car item) item))) '(elli up very_[_very_small_]))
	  (if (member (cdr new-feature) feature-values :test 'equalp)
	    (let* ((index (position (cdr new-feature) feature-values :test 'equalp))
		    (weight (car (nth index feature))))
	      (if success? (setf weight (strengthen :weight weight)) (setf weight (weaken :weight weight)))
	      (setf (car (nth index feature)) weight))
	    (push new-feature feature))
	  (>> g (list 'nodes start 'feature) feature)))
      (list distance success?))))

;; max > 1
(defun test-elaborate (g)
  (let* ((objs (remove-if-not (lambda (x) (equal (>> g `(nodes ,x type)) 'obj)) (hash-keys (>> g 'nodes))))
	  (distans '(0))
	  (successes '(0))
	  (successes-segment '())
	  (success-rates-ltm '(0))
	  (success-rates-stm '(0))
	  (obj nil)
	  (result nil)
	  (timex 0)
	  (distan-level 0.3)
	  (distan-levels (list distan-level)))
    (loop do 
      (show "test-elaborate random-selected obj {}" obj)
      (setf obj (random-choice objs))
      (setf successes-segment (subseq successes (- (length successes) (min (length successes) 10))))
      (when (and (> timex 49) (= (mod timex 50) 0) (> (car (last success-rates-ltm)) 0.7)) (> (car (last success-rates-stm)) 0.8) (setf distan-level (min 0.6 (+ distan-level 0.05))))
      (setf result (elaborate g :obj obj :distance-range (list distan-level 1))) ;(0 1)->distan 0.4926472  '(0.6 1)-> 0.49698198  '(0.3 0.4)-> 0.50051016
      (setf distan-levels (append distan-levels (list distan-level)))
      (setf distans (append distans (list (car result))))
      (setf successes (append successes (list (second result))))
      (setf success-rates-ltm (append success-rates-ltm (list (/ (count t successes) (length successes)))))
      (setf success-rates-stm (append success-rates-stm (list (/ (count t successes-segment) (length successes-segment)))))
      ;;(vgplot:plot (range (length distans)) distans ";distans;" (range (length success-rates-ltm))
	;;success-rates-ltm ";success-rates-ltm;" success-rates-stm ";success-rates-stm;"
	;;(range (length distan-levels)) distan-levels ";distan-levels;")
      (incf timex)
      while (or (< timex 100) (<= distan-level 0.45) (< (car (last success-rates-ltm)) 0.8) (< (car (last success-rates-stm)) 0.8)))
    (show "distans of elaborations: {} average {}" distans (average distans))))

;;(let ((a '(0.2 0.4 0.1 0.6)) (b1 '(0.3 0.3 0.2 0.5)) (b2 '(0.3 0.6 0.3 0.9))) (vgplot:plot a ";a;" b1 ";b1;" b2 ";b2;"))

;;replace edges max 0.7, replace nodes max 1 (set max as 0.65)
(defun test-replacement (g)
  (let* ((samples-edge (mapcar (lambda (x) (s2l x)) (remove-if (lambda (x) (intersect '(expan imagine) (hash-keys (>> g `(edges ,x))))) (hash-keys (>> g 'edges)))))
	  (samples-node (remove-if-not (lambda (x) (equal (>> g `(nodes ,x type)) 'obj)) (hash-keys (>> g 'nodes))))
	  (samples (append samples-edge samples-node))
	  (distans '())
	  (successes '()))
    (show "samples {}" samples)
    (dotimes (i 100)
      (show "start a replacement ...")
      (let* ((sample (random-choice samples))
	      (result (replace-items g :start sample :distance-range (list 0.2 1)))
	      )
	(push (car result) distans)
	(push (second result) successes)
	(show "sample {}" sample)
	)
      (show "end a replacement ..."))
    (setf distans (remove nil distans))
    (show "distans of replacement: {}" distans)
    (setf successes (mapcar (lambda (x) (let ((sublst (subseq successes 0 (+ x 1)))) (/ (count t sublst) (length sublst)))) (range (length successes))))
    ;;(vgplot:plot (range (length distans)) distans ";distans;" (range (length successes)) successes ";successes;")
    ))
;;successes -> rate: (let ((lst '(nil t t nil t t nil nil t t t t t))) (mapcar (lambda (x) (let ((sublst (subseq lst 0 (+ x 1)))) (/ (count t sublst) (length sublst)))) (range (length lst))))

;;((int left) (vi elli (up left) (very small)) (fad tria left (very small)))
;;node-obj: (shape direct size)
;;node-bg: (shape direct size density) ;density: small-sky medium-sea large-lan
;;edge: (topo direct)

#|
(show "{}"
  (>> 'scene (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children '(sky-obj sea-obj lan-obj) 'parents nil 'peers nil)
    'sky-obj (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children '(sky sun) 'parents 'scene 'peers (>> 'sea-obj (>> 'inout? 'out 'touch? t 'direct 'up) 'lan-obj (>> 'inout? 'intersect 'touch? nil 'direct '(up left))))
    'sea-obj (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children '(sea boat fish) 'parents 'scene 'peers (>> 'sky-obj (>> 'inout? 'out 'touch? t 'direct 'down) 'lan-obj (>> 'inout? 'intersect 'touch? nil 'direct 'left)))
    'lan-obj (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children '(lan house tree) 'parents 'scene 'peers (>> 'sky-obj (>> 'inout? 'intersect 'touch? nil 'direct '(down right)) 'sea-obj (>> 'inout? 'intersect 'touch? nil 'direct 'right)))
    'sky (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children nil 'parents 'sky-obj 'peers (>> 'sun (>> 'inout? 'contain 'touch? nil 'direct '(down right))))
    'sea (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children nil 'parents 'sea-obj 'peers (>> 'boat (>> 'inout? 'intersect 'touch? nil 'direct '(down right)) 'fish (>> 'inout? 'contain 'touch? nil 'direct 'right)))
    'lan (>> 'self (>> 'size 'large 'shape 'rect 'direct 'right) 'children nil 'parents 'lan-obj 'peers (>> 'house (>> 'inout? 'out 'touch? t 'direct '(down right)) 'tree (>> 'inout? 'out 'touch? t 'direct '(down left))))
    'sun (>> 'self (>> 'size 'small 'shape 'elli 'direct 'right) 'children nil 'parents 'sky-obj 'peers (>> 'sky (>> 'inout? 'in 'touch? nil 'direct '(up left))))
    'boat (>> 'self (>> 'size 'small 'shape 'poly 'direct 'right) 'children '(hul bow pop sal) 'parents 'sea-obj 'peers (>> 'sea (>> 'inout? 'intersect 'touch? nil 'direct '(up left)) 'fish (>> 'inout? 'out 'touch? nil 'direct 'up)))
    'fish (>> 'self (>> 'size 'small 'shape 'poly 'direct 'right) 'children '(fad fdy fye fil) 'parents 'sea-obj 'peers (>> 'sea (>> 'inout? 'in 'touch? nil 'direct 'left) 'boat (>> 'inout? 'out 'touch? nil 'direct 'down)))
    'house (>> 'self (>> 'size 'medium 'shape 'poly 'direct 'right) 'children '(rof wal-obj) 'parents 'lan-obj 'peers (>> 'lan (>> 'inout? 'out 'touch? t 'direct '(left up)) 'tree (>> 'inout? 'out 'touch? nil 'direct 'left)))
    'tree (>> 'self (>> 'size 'small 'shape 'poly 'direct 'up) 'children '(trk cro crw) 'parents 'lan-obj 'peers (>> 'lan (>> 'inout? 'out 'touch? t 'direct '(right up)) 'house (>> 'inout? 'out 'touch? nil 'direct 'right)))
    'hul (>> 'self (>> 'size 'small 'shape 'poly 'direct 'up) 'children '(trk cro crw) 'parents 'lan-obj 'peers (>> 'lan (>> 'inout? 'out 'touch? t 'direct '(right up)) 'house (>> 'inout? 'out 'touch? nil 'direct 'right)))
    ))
|#

(defun graph (&optional (g (make-graph)) (s (get-scene3)))
  (mapcar (lambda (x) (add-node g :props (>> s x) :node x)) (hash-keys s))
  (mapcar (lambda (x) (>> g `(nodes ,x feature) (list (list 1 (>> s `(,x shape)) (name-direction :angle (>> s `(,x a))) (name-size :size (abs (area-polygon (obj2polygon (>> s x)))) :size0 80 :scale 5))))) (hash-keys (>> g 'nodes)))
  (show "get-relations...")
  (get-relations :r g :scene s);;pair-objs
  (show "get compo-objs...")
  (let ((pair-objs (mapcar (lambda (x) (s2l x)) (hash-keys (>> g 'edges))))
	 (groups '()))
    (dolist (pair pair-objs)
      (if (null groups)
	(push (list pair) groups)
	(let ((switch nil))
	  (dotimes (i (length groups))
	    (dolist (p (nth i groups))
	      (when (intersect pair p)
		(push pair (nth i groups))
		(setf switch t)
		(return)))
	    (when switch (return)))
	  (when (null switch)
	    (push (list pair) groups)))))
    (let* ((group-objs (mapcar (lambda (x) (remove-duplicates (flatten x))) groups))
	    (group-polygons (mapcar (lambda (x) (convex-hull (pair-items (flatten (mapcar (lambda (y) (obj2polygon (>> s y))) x))))) group-objs))
	    (areas (mapcar (lambda (x) (area-polygon x)) group-polygons))
	    (sizes (mapcar (lambda (x) (name-size :size x :size0 80 :scale 5)) areas))
	    (centers (mapcar (lambda (x) (centroid-of-polygon x)) group-polygons)))
      (mapcar (lambda (compo-obj objs poly area size center) (add-node g :props (>> 'feature (list (list 1 'poly size)) 'objs objs 'outline poly 'area area 'type 'compo-obj 'x (car center) 'y (second center)) :node compo-obj)) '(fish boat tree house) group-objs group-polygons areas sizes centers))
    (let ((feature (car (>> g `(nodes fish feature)))))
      (insert feature 1 'left)
      (>> g `(nodes fish feature) (list feature)))
    (let ((feature (car (>> g `(nodes boat feature)))))
      (insert feature 1 'left)
      (>> g `(nodes boat feature) (list feature)))
    (let ((feature (car (>> g `(nodes tree feature)))))
      (insert feature 1 'up)
      (>> g `(nodes tree feature) feature))
    (let ((feature (car (>> g `(nodes house feature)))))
      (insert feature 1 'up)
      (>> g `(nodes house feature) feature))
    (let ((feature (car (>> g `(nodes sky feature)))))
      (setf feature (append feature (list 'small)))
      (>> g `(nodes sky feature) (list feature)))
    (let ((feature (car (>> g `(nodes sea feature)))))
      (setf feature (append feature (list 'medium)))
      (>> g `(nodes sea feature) (list feature)))
    (let ((feature (car (>> g `(nodes lan feature)))))
      (setf feature (append feature (list 'large)))
      (>> g `(nodes lan feature) (list feature))) 
    (setf groups (mapcar (lambda (x y) (append (list x) (list y))) '(fish boat tree house) groups))
    (mapcar (lambda (x) (add-edge g :edge (l2s x) :props (>> 'expan t))) groups)
    )
  (show "get-relations-compo...")
  (get-relations-compo g)

  (add-edge g :edge (l2s '(bt (relations obj obj))) :props (>> 'expan t))
  (add-edge g :edge (l2s '(relations (topo direct))) :props (>> 'expan t))
  (mapcar (lambda (x) (add-edge g :edge (l2s (list 'topo x)) :props (>> 'expan t))) '(in tin int on))
  (mapcar (lambda (x) (add-edge g :edge (l2s (list 'direct x)) :props (>> 'expan t))) '(up right down left (up right) (up left) (down right) (down left)))
  
  (add-edge g :edge (l2s (list 'obj (list '({ read-from-string (random-word) }) 'shape 'direct 'size))) :props (>> 'expan t))
  (mapcar (lambda (x) (add-edge g :edge (l2s (list 'shape x)) :props (>> 'expan t))) '(tria rect elli))
  (mapcar (lambda (x) (add-edge g :edge (l2s (list 'size x)) :props (>> 'expan t))) '(small medium large (very small) (very (very small)) (very large) (very (very large))))
  (show "{}" g)
  (show "trace-fd g 'house {}" (trace-fd g :start 'house :choice-reverse? nil))
  (show "trace-fd g 'house level 1 {}" (trace-fd g :start 'house :choice-reverse? nil :level 1))
  (show "trace-fd g '(house lan) {}" (trace-fd g :start '(house lan) :choice-reverse? nil))
  (show "trace-fd g '(house lan) level 1 {}" (trace-fd g :start '(house lan) :choice-reverse? nil :level 1))
  (show "trace-fd g '(fye fad) {}" (trace-fd g :start '(fye fad) :choice-reverse? nil))
  (show "trace-fd g 'fad {}" (trace-fd g :start 'fad :choice-reverse? nil))
  (show "trace-fd g '(relations obj fad) {}" (trace-fd g :start '(relations obj fad) :choice-reverse? nil))
  (show "replace-items g '(sal hul) {}" (replace-items g :start '(sal hul) :distance-range (list 0.2 1)))
  (show "replace-items g '(boat sea) {}" (replace-items g :start '(boat sea) :distance-range (list 0.2 1)))
  (show "replace-items g 'fad {}" (replace-items g :start 'fad :distance-range (list 0.2 1)))
  (show "distan 'fish 'boat {}" (distan g 'fish 'boat))
  (test-elaborate g)
  ;;(test-replacement g)
  ;;(show "trace-fd g 'bt {}" (trace-fd g :start 'bt :choice-reverse? nil))
  ;;(show "(elaborate g 'fad) {}" (elaborate g :obj 'fad :distance-range (list 0.1 1))) 
  (show "{}" g)
  )
;;(graph)

;;(show "{}" (>> (format nil "~a" '("house" (("rof" "wal") ("dor" "wal") ("win" "wal")))) (>> "shape" "tria" "size" "small")))
;;(let ((h (>> "shape" "tria" "size" "small"))) (>> h (car (hash-keys h))))
;;(let ((h (>> "shape" "tria" "size" "small"))) (>> h "shape"))
;;(gethash 'shape (>> 'shape "tria" 'size "small"))
;;size_[_very_[_very_small_]_]

(defun eucli-distan (&optional (lst0 '(1 3 2)) (lst1 '(4 2 6)))
  (sqrt (apply #'+ (mapcar (lambda (x y) (expt (- x y) 2)) lst0 lst1))))
;;(eucli-distan)

(defun normalize-weighted-list (&optional (lst '((1 0) (0.1 0.1) (0.05 0.2) (0.01 0.3))));;the first is weight, second is value
  (let ((total-weight (apply #'+ (mapcar (lambda (x) (car x)) lst))))
    (mapcar (lambda (x) (append (list (/ (car x) total-weight)) (cdr x))) lst)))
;;(show "{}" (normalize-weighted-list))

(defun distance-to-weighted-list (&key (sample 0.1) (lst '((1 0) (0.1 0.1) (0.05 0.2) (0.01 0.3))))
  (setf lst (normalize-weighted-list lst))
  (cond
    ((numberp sample)
      (apply #'+ (mapcar (lambda (x) (* (abs (- sample (second x))) (car x))) lst)))
    ((listp sample)
      (apply #'+ (mapcar (lambda (x) (* (eucli-distan sample (cdr x)) (car x))) lst)))
    (t nil)))
;;(distance-to-weighted-list :sample 0.5 :lst '((1 0) (0.1 0.1) (0.05 0.2) (0.01 0.3)))
;;(distance-to-weighted-list :sample '(0.1 0.2) :lst '((1 0 0) (0.1 0.1 0.2) (0.05 0.2 0.3) (0.01 0.3 0.4)))
;;(distance-to-weighted-list :sample 1.0 :lst '((1 0) (0.9 0.1) (0.9 0.2) (0.9 0.3) (0.9 0.4) (0.9 0.5) (0.9 0.6) (0.9 0.7) (0.9 0.8) (0.9 0.9)))


